{"version":3,"sources":["context/grid/gridContext.js","context/grid/gridReducer.js","context/types.js","parameters.js","context/grid/GridState.js","PathfinderVisualizer/Vertex/Vertex.js","Components/Methods.js","PathfinderVisualizer/Initializers/GridInitializers.js","PathfinderVisualizer/PathfinderVisualizer.jsx","PathfinderVisualizer/Initializers/GridReset.js","algorithms/dijkstra.js","algorithms/astar.js","PathfinderVisualizer/Visualizers/Visualize.js","algorithms/bfs_dfs.js","Components/Navbar.js","App.js","serviceWorker.js","index.js"],"names":["GridContext","createContext","state","action","type","grid","payload","start_vertex_row","start_vertex_col","finish_vertex_row","finish_vertex_col","mouseIsPressed","isDragging","original_row","original_col","translate_row","translate_col","last_translate_row","last_translate_col","distanceMethod","allowDiagonal","algorithm","ROWS","COLUMNS","Math","floor","window","innerWidth","GridState","props","initialState","useReducer","gridReducer","dispatch","Provider","value","setGrid","setStart","position","row","col","setFinish","setMouseIsPressed","pressed","setIsDragging","started_dragging","setOriginal","setTranslate","setLastTranslate","setDistanceMethod","method","setAllowDiagonal","diagonal","setAlgorithm","children","Vertex","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","isVisited","isPath","onDragStart","onDragOver","onDrop","extraClassName","distance","id","className","draggable","DistancePicker","getDistanceMethod","chooseDiagonal","getWhichAlgorithm","gridContext","React","useContext","handleDistanceMethod","event","target","handleAlgorithmMethod","style","display","marginTop","textAlign","FormGroup","FormControlLabel","control","Radio","checked","onChange","name","label","disabled","Checkbox","createInitialGrid","start_finish","thisRow","push","createVertex","Infinity","distanceToThis","heuristic","previousVertex","createGridWithWalls","wallGrid","vertex","newVertex","updateGrid","PathfinderVisualizer","useEffect","handleDrag","clearTheVisualOfVertex","thisVertex","document","getElementById","map","row_index","key","vertex_index","handleMouseDown","handleMouseEnter","e","vertexData","JSON","stringify","dataTransfer","setData","handleDragStart","preventDefault","stopPropagation","handleDragOver","new_position","parse","getData","dragged_from_position","empty_vertex","swapVertices","clearData","handleDrop","onDrag","resetGrid","dijkstra","start","finish","visitedInOrder","unvisitedVertices","getAllVertices","length","getTheClosestVerticesFirst","closestVertex","shift","console","log","updateUnvisitedNeighbors","vertices","sort","vertexA","vertexB","getUnvisitedNeighbors","hVDistance","dDistance","t","backtrackRoute","backtrackedVertices","currentVertex","unshift","astar","tempF","distanceFromStartToThis","calculateHeuristic","from","to","EuclideanDistance","Point","Goal","sqrt","pow","animateAlgorithm","i","setTimeout","animateShortestPath","bfs_dfs","structure","neighbors","pop","getNeighbors","forEach","neighbor","Navbar","visualizeAlgorithm","startVertex","finishVertex","onClick","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.13057214.chunk.js","sourcesContent":["import { createContext } from \"react\";\n\nconst GridContext = createContext();\n\nexport default GridContext;\n","/**\n *\n * Deleted all the get actions, because triggering the data\n * does not happen in the reducer. Only setting the state values happen\n * in reducer.\n * State values can be retrieved inside the functional component itself.\n *\n */\n\nimport {\n  SET_GRID,\n  SET_STARTING_ROW,\n  SET_STARTING_COL,\n  SET_FINISH_ROW,\n  SET_FINISH_COL,\n  SET_MOUSE_IS_PRESSED,\n  IS_DRAGGING,\n  SET_ORIGINAL_ROW,\n  SET_ORIGINAL_COL,\n  SET_TRANSLATE_ROW,\n  SET_TRANSLATE_COL,\n  SET_LAST_TRANSLATE_ROW,\n  SET_LAST_TRANSLATE_COL,\n  SET_DISTANCE_METHOD,\n  SET_ALLOW_DIAGONAL,\n  SET_ALGORITHM\n} from \"../types.js\";\n\nexport default (state, action) => {\n  switch (action.type) {\n    case SET_GRID:\n      return { ...state, grid: action.payload };\n\n    case SET_STARTING_ROW:\n      return { ...state, start_vertex_row: action.payload };\n\n    case SET_STARTING_COL:\n      return { ...state, start_vertex_col: action.payload };\n\n    case SET_FINISH_ROW:\n      return { ...state, finish_vertex_row: action.payload };\n\n    case SET_FINISH_COL:\n      return { ...state, finish_vertex_col: action.payload };\n\n    case SET_MOUSE_IS_PRESSED:\n      return { ...state, mouseIsPressed: action.payload };\n    // related to dragging :\n    case IS_DRAGGING:\n      return { ...state, isDragging: action.payload };\n\n    case SET_ORIGINAL_ROW:\n      return { ...state, original_row: action.payload };\n\n    case SET_ORIGINAL_COL:\n      return { ...state, original_col: action.payload };\n\n    case SET_TRANSLATE_ROW:\n      return { ...state, translate_row: action.payload };\n\n    case SET_TRANSLATE_COL:\n      return { ...state, translate_col: action.payload };\n\n    case SET_LAST_TRANSLATE_ROW:\n      return { ...state, last_translate_row: action.payload };\n\n    case SET_LAST_TRANSLATE_COL:\n      return { ...state, last_translate_col: action.payload };\n\n    case SET_DISTANCE_METHOD:\n      return {\n        ...state,\n        distanceMethod: action.payload\n      };\n\n    case SET_ALLOW_DIAGONAL:\n      return {\n        ...state,\n        allowDiagonal: action.payload\n      };\n\n    case SET_ALGORITHM:\n      return {\n        ...state,\n        algorithm: action.payload\n      };\n\n    default:\n      return state;\n  }\n};\n","export const SET_GRID = \"SET_GRID\";\nexport const SET_STARTING_ROW = \"SET_STARTING_ROW\";\nexport const SET_STARTING_COL = \"SET_STARTING_COL\";\nexport const SET_FINISH_ROW = \"SET_FINISH_ROW\";\nexport const SET_FINISH_COL = \"SET_FINISH_COL\";\n\nexport const SET_MOUSE_IS_PRESSED = \"SET_MOUSE_IS_PRESSED\";\n\nexport const IS_DRAGGING = \"IS_DRAGGING\";\n\nexport const SET_ORIGINAL_ROW = \"SET_ORIGINAL_ROW\";\nexport const SET_ORIGINAL_COL = \"SET_ORIGINAL_COL\";\n\nexport const SET_TRANSLATE_ROW = \"SET_TRANSLATE_ROW\";\nexport const SET_TRANSLATE_COL = \"SET_TRANSLATE_COL\";\n\nexport const SET_LAST_TRANSLATE_ROW = \"SET_LAST_TRANSLATE_ROW\";\nexport const SET_LAST_TRANSLATE_COL = \"SET_LAST_TRANSLATE_COL\";\nexport const SET_DISTANCE_METHOD = \"SET_DISTANCE_METHOD\";\nexport const SET_ALLOW_DIAGONAL = \"SET_ALLOW_DIAGONAL\";\n\nexport const SET_ALGORITHM = \"SET_ALGORITHM\";\n","export const ROWS = 25;\nexport const COLUMNS = Math.floor(window.innerWidth / 35);\nexport const FAST = 10;\nexport const MEDIUM = 40;\nexport const SLOW = 80;\nexport const speed = SLOW;\n\nexport const START_VERTEX_ROW_ = 3;\nexport const START_VERTEX_COL_ = 3;\nexport const FINISH_VERTEX_ROW_ = 7;\nexport const FINISH_VERTEX_COL_ = 20;\n","import React, { useReducer } from \"react\";\nimport gridContext from \"./gridContext\";\nimport gridReducer from \"./gridReducer\";\n\nimport {\n  START_VERTEX_ROW_,\n  START_VERTEX_COL_,\n  FINISH_VERTEX_ROW_,\n  FINISH_VERTEX_COL_\n} from \"../../parameters\";\n\nimport {\n  SET_GRID,\n  SET_STARTING_ROW,\n  SET_STARTING_COL,\n  SET_FINISH_ROW,\n  SET_FINISH_COL,\n  SET_MOUSE_IS_PRESSED,\n  IS_DRAGGING,\n  SET_ORIGINAL_ROW,\n  SET_ORIGINAL_COL,\n  SET_TRANSLATE_ROW,\n  SET_TRANSLATE_COL,\n  SET_LAST_TRANSLATE_ROW,\n  SET_LAST_TRANSLATE_COL,\n  SET_DISTANCE_METHOD,\n  SET_ALLOW_DIAGONAL,\n  SET_ALGORITHM\n} from \"../types.js\";\n\nconst GridState = props => {\n  const initialState = {\n    grid: [],\n\n    mouseIsPressed: false,\n\n    start_vertex_row: START_VERTEX_ROW_,\n    start_vertex_col: START_VERTEX_COL_,\n    finish_vertex_row: FINISH_VERTEX_ROW_,\n    finish_vertex_col: FINISH_VERTEX_COL_,\n\n    isDragging: false,\n\n    original_row: 0,\n    original_col: 0,\n\n    translate_row: 0,\n    translate_col: 0,\n\n    last_translate_row: 0,\n    last_translate_col: 0,\n\n    distanceMethod: \"manhattan\",\n\n    allowDiagonal: false,\n\n    algorithm: \"dijkstra\"\n  };\n\n  const [state, dispatch] = useReducer(gridReducer, initialState);\n\n  const setGrid = grid => {\n    dispatch({ type: SET_GRID, payload: grid });\n  };\n\n  const setStart = position => {\n    dispatch({ type: SET_STARTING_ROW, payload: position.row });\n    dispatch({ type: SET_STARTING_COL, payload: position.col });\n  };\n\n  const setFinish = position => {\n    dispatch({ type: SET_FINISH_ROW, payload: position.row });\n    dispatch({ type: SET_FINISH_COL, payload: position.col });\n  };\n\n  const setMouseIsPressed = pressed => {\n    dispatch({ type: SET_MOUSE_IS_PRESSED, payload: pressed });\n  };\n\n  //   for dragging actions\n  const setIsDragging = started_dragging => {\n    dispatch({ type: IS_DRAGGING, payload: started_dragging });\n  };\n\n  const setOriginal = position => {\n    dispatch({ type: SET_ORIGINAL_ROW, payload: position.row });\n    dispatch({ type: SET_ORIGINAL_COL, payload: position.col });\n  };\n\n  const setTranslate = position => {\n    dispatch({ type: SET_TRANSLATE_ROW, payload: position.row });\n    dispatch({ type: SET_TRANSLATE_COL, payload: position.col });\n  };\n\n  const setLastTranslate = position => {\n    dispatch({ type: SET_LAST_TRANSLATE_ROW, payload: position.row });\n    dispatch({ type: SET_LAST_TRANSLATE_COL, payload: position.col });\n  };\n\n  const setDistanceMethod = method => {\n    dispatch({ type: SET_DISTANCE_METHOD, payload: method });\n  };\n\n  const setAllowDiagonal = diagonal => {\n    dispatch({ type: SET_ALLOW_DIAGONAL, payload: diagonal });\n  };\n\n  const setAlgorithm = algorithm => {\n    dispatch({ type: SET_ALGORITHM, payload: algorithm });\n  };\n  return (\n    <gridContext.Provider\n      value={{\n        grid: state.grid,\n        setGrid,\n        setStart,\n        setFinish,\n        setMouseIsPressed,\n        setIsDragging,\n        setOriginal,\n        setTranslate,\n        setLastTranslate,\n        mouseIsPressed: state.mouseIsPressed,\n        start_vertex_row: state.start_vertex_row,\n        start_vertex_col: state.start_vertex_col,\n        finish_vertex_row: state.finish_vertex_row,\n        finish_vertex_col: state.finish_vertex_col,\n        isDragging: state.isDragging,\n        original_row: state.original_row,\n        original_col: state.original_col,\n        translate_row: state.translate_row,\n        translate_col: state.translate_col,\n        last_translate_row: state.last_translate_row,\n        last_translate_col: state.last_translate_col,\n        setDistanceMethod,\n        distanceMethod: state.distanceMethod,\n        allowDiagonal: state.allowDiagonal,\n        setAllowDiagonal,\n        setAlgorithm,\n        algorithm: state.algorithm\n      }}\n    >\n      {props.children}\n    </gridContext.Provider>\n  );\n};\n/**\n * ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n * this is where we return the state variables\n */\n\nexport default GridState;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport \"./Vertex.css\";\n\nconst Vertex = props => {\n  const {\n    position,\n    isFinish,\n    isStart,\n    isWall,\n    onMouseDown,\n    onMouseEnter,\n    onMouseUp,\n    isVisited,\n    isPath,\n    onDragStart,\n    onDragOver,\n    onDrop,\n    distance\n  } = props;\n  const extraClassName = isFinish\n    ? \"vertex-finish\"\n    : isStart\n    ? \"vertex-start\"\n    : isWall\n    ? \"vertex-wall vertex-non-draggable\"\n    : isPath\n    ? \"vertex-shortest-path vertex-non-draggable\"\n    : isVisited\n    ? \"vertex-visited vertex-non-draggable\"\n    : \"vertex-non-draggable\";\n\n  return (\n    <td\n      id={`vertex-${position.row}-${position.col}`}\n      className={`vertex ${extraClassName}`}\n      onMouseDown={() => onMouseDown(position)}\n      onMouseEnter={() => onMouseEnter(position)}\n      onMouseUp={() => onMouseUp(position)}\n      onDragStart={onDragStart}\n      onDragOver={onDragOver}\n      onDrop={onDrop}\n      draggable={(isStart || isFinish) && !isWall}\n    >\n      {/* {distance === Infinity ? \"I\" : distance} */}\n      {/* {(position.row, position.col)} */}\n    </td>\n  );\n};\n\nVertex.propTypes = {\n  position: PropTypes.object,\n  isFinish: PropTypes.bool,\n  isStart: PropTypes.bool,\n  isWall: PropTypes.bool,\n  onMouseDown: PropTypes.func,\n  onMouseUp: PropTypes.func,\n  onMouseEnter: PropTypes.func,\n  mouseIsPressed: PropTypes.bool\n};\n\nexport default Vertex;\n","import React from \"react\";\nimport Radio from \"@material-ui/core/Radio\";\nimport Checkbox from \"@material-ui/core/Checkbox\";\nimport FormControlLabel from \"@material-ui/core/FormControlLabel\";\nimport FormGroup from \"@material-ui/core/FormGroup\";\n\nimport GridContext from \"../context/grid/gridContext\";\n\nconst DistancePicker = ({\n  getDistanceMethod,\n  chooseDiagonal,\n  getWhichAlgorithm\n}) => {\n  const gridContext = React.useContext(GridContext);\n  const {\n    allowDiagonal,\n    distanceMethod,\n    setAllowDiagonal,\n    setDistanceMethod,\n    setAlgorithm,\n    algorithm\n  } = gridContext;\n\n  const handleDistanceMethod = event => {\n    setDistanceMethod(event.target.value);\n    getDistanceMethod(event.target.value);\n  };\n\n  const handleDiagonal = event => {\n    setAllowDiagonal(event.target.checked);\n    chooseDiagonal(event.target.checked);\n  };\n\n  const handleAlgorithmMethod = event => {\n    setAlgorithm(event.target.value);\n    getWhichAlgorithm(event.target.value);\n  };\n\n  return (\n    <div style={{ display: \"block\", marginTop: \"130px\", textAlign: \"center\" }}>\n      <FormGroup row style={{ textAlign: \"center\", display: \"block\" }}>\n        <FormControlLabel\n          control={\n            <Radio\n              checked={algorithm === \"dijkstra\"}\n              onChange={handleAlgorithmMethod}\n              value=\"dijkstra\"\n              name=\"choose-distance-method\"\n              label=\"dijkstra\"\n            />\n          }\n          label=\"Dijkstra\"\n        />\n        <FormControlLabel\n          control={\n            <Radio\n              checked={algorithm === \"astar\"}\n              onChange={handleAlgorithmMethod}\n              value=\"astar\"\n              name=\"choose-distance-method\"\n              label=\"astar\"\n            />\n          }\n          label=\"A-star\"\n        />\n        <FormControlLabel\n          control={\n            <Radio\n              checked={algorithm === \"bfs\"}\n              onChange={handleAlgorithmMethod}\n              value=\"bfs\"\n              name=\"choose-distance-method\"\n              label=\"bfs\"\n            />\n          }\n          label=\"Breadth-First Search\"\n        />\n        <FormControlLabel\n          control={\n            <Radio\n              checked={algorithm === \"dfs\"}\n              onChange={handleAlgorithmMethod}\n              value=\"dfs\"\n              name=\"choose-distance-method\"\n              label=\"dfs\"\n            />\n          }\n          label=\"Depth-First Search\"\n        />\n      </FormGroup>\n\n      <FormGroup row style={{ textAlign: \"center\", display: \"block\" }}>\n        <FormControlLabel\n          control={\n            <Radio\n              checked={distanceMethod === \"manhattan\"}\n              onChange={handleDistanceMethod}\n              value=\"manhattan\"\n              name=\"choose-distance-method\"\n              label=\"m\"\n              disabled={algorithm === \"astar\" || !allowDiagonal}\n            />\n          }\n          label=\"manhattan\"\n        />\n        <FormControlLabel\n          control={\n            <Radio\n              checked={distanceMethod === \"chebyshev\"}\n              onChange={handleDistanceMethod}\n              value=\"chebyshev\"\n              name=\"choose-distance-method\"\n              label=\"c\"\n              disabled={algorithm === \"astar\" || !allowDiagonal}\n            />\n          }\n          label=\"chebyshev\"\n        />\n        <FormControlLabel\n          control={\n            <Radio\n              checked={distanceMethod === \"euclidean\"}\n              onChange={handleDistanceMethod}\n              value=\"euclidean\"\n              name=\"choose-distance-method\"\n              label=\"e\"\n              disabled={algorithm === \"astar\" || !allowDiagonal}\n            />\n          }\n          label=\"euclidean\"\n        />\n        <FormControlLabel\n          control={\n            <Checkbox\n              checked={allowDiagonal}\n              onChange={handleDiagonal}\n              disabled={algorithm === \"astar\"}\n            />\n          }\n          label=\"diagonal\"\n        />\n      </FormGroup>\n    </div>\n  );\n};\n\nexport default DistancePicker;\n","import { ROWS, COLUMNS } from \"../../parameters\";\n\nexport const createInitialGrid = start_finish => {\n  const grid = [];\n  for (let row = 0; row < ROWS; row++) {\n    const thisRow = [];\n    for (let col = 0; col < COLUMNS; col++) {\n      thisRow.push(createVertex({ row, col }, start_finish));\n    }\n    grid.push(thisRow);\n  }\n  // for testing\n  //   for (let row = 0; row < 20; row++) {\n  //     grid[row][14].isWall = true;\n  //   }\n  return grid;\n};\n\n// export const visualizeAlgorithm = () => {\n//   const gridContext = useContext(GridContext);\n\n//   const {\n//     grid,\n\n//     start_vertex_row,\n//     start_vertex_col,\n//     finish_vertex_row,\n//     finish_vertex_col,\n\n//     distanceMethod,\n//     allowDiagonal,\n\n//     algorithm\n//   } = gridContext;\n\n//   clearTheVisualOfVertex();\n//   document.getElementById(\"root\").style = \"pointer-events: none\";\n//   document.getElementById(\"btnStart\").disabled = true;\n//   document.getElementById(\"btnReset\").disabled = true;\n//   for (let row = 0; row < ROWS; row++) {\n//     for (let col = 0; col < COLUMNS; col++) {\n//       let thisVertex = grid[row][col];\n\n//       if (thisVertex.isStart)\n//         document.getElementById(`vertex-${row}-${col}`).className =\n//           \"vertex vertex-start\";\n//       else if (thisVertex.isFinish)\n//         document.getElementById(`vertex-${row}-${col}`).className =\n//           \"vertex vertex-finish\";\n//       else if (thisVertex.isWall)\n//         document.getElementById(`vertex-${row}-${col}`).className =\n//           \"vertex vertex-wall\";\n//       else if (thisVertex.isVisited)\n//         document.getElementById(`vertex-${row}-${col}`).className = \"vertex\";\n//     }\n//   }\n//   const startVertex = grid[start_vertex_row][start_vertex_col];\n//   const finishVertex = grid[finish_vertex_row][finish_vertex_col];\n//   let visitedInOrder;\n\n//   switch (algorithm) {\n//     case \"astar\":\n//       visitedInOrder = astar(grid, startVertex, finishVertex);\n//       break;\n//     case \"dijkstra\":\n//       visitedInOrder = dijkstra(\n//         grid,\n//         startVertex,\n//         finishVertex,\n//         distanceMethod,\n//         allowDiagonal\n//       );\n//       break;\n//     case \"dfs\":\n//       visitedInOrder = bfs_dfs(grid, startVertex, finishVertex, \"dfs\");\n//       break;\n//     case \"bfs\":\n//       visitedInOrder = bfs_dfs(grid, startVertex, finishVertex, \"bfs\");\n//       break;\n//     default:\n//       visitedInOrder = dijkstra(\n//         grid,\n//         startVertex,\n//         finishVertex,\n//         distanceMethod,\n//         allowDiagonal\n//       );\n//   }\n//   // console.log(grid);\n//   // console.log(visitedInOrder);\n//   const backtrackedVertices = backtrackRoute(finishVertex, startVertex);\n//   animateAlgorithm(visitedInOrder, backtrackedVertices);\n// };\n\nconst createVertex = (position, start_finish) => {\n  const {\n    start_vertex_row,\n    start_vertex_col,\n    finish_vertex_row,\n    finish_vertex_col\n  } = start_finish;\n  return {\n    position,\n    isStart:\n      position.row === start_vertex_row && position.col === start_vertex_col,\n    isFinish:\n      position.row === finish_vertex_row && position.col === finish_vertex_col,\n    distance: Infinity,\n    distanceToThis: 0,\n    heuristic: 0,\n    isVisited: false,\n    isWall: false,\n    isPath: false,\n    previousVertex: null,\n    draggable:\n      (position.row === start_vertex_row &&\n        position.col === start_vertex_col) ||\n      (position.row === finish_vertex_row && position.col === finish_vertex_col)\n  };\n};\n\nexport const createGridWithWalls = (grid, position) => {\n  const wallGrid = [...grid];\n  const vertex = wallGrid[position.row][position.col];\n  const newVertex = {\n    ...vertex,\n    isWall: !vertex.isWall, //changed here\n    isPath: false,\n    isVisited: false,\n    distance: Infinity,\n    distanceToThis: Infinity,\n    heuristic: Infinity,\n    draggable: false,\n    previousVertex: null\n  };\n  wallGrid[position.row][position.col] = newVertex;\n  return wallGrid;\n};\n\nexport const createGridWithWallsOnRowOrColumn = (\n  grid,\n  orientation,\n  start,\n  end,\n  division_point,\n  skip_this_cell\n) => {\n  console.log(\n    `Orientation is: ${orientation} Division point is ${division_point}, skipping the cell ${skip_this_cell}, `\n  );\n  const wallgrid = [...grid];\n  if (orientation === \"vertical\") {\n    for (let row = start; row < end; row++) {\n      if (\n        grid[row][division_point].isStart ||\n        grid[row][division_point].isFinish\n      )\n        continue;\n      if (row !== skip_this_cell) {\n        let vertex = wallgrid[row][division_point];\n        let newVertex = {\n          ...vertex,\n          isWall: !vertex.isWall, //changed here\n          isPath: false,\n          isVisited: false,\n          distance: Infinity,\n          distanceToThis: Infinity,\n          heuristic: Infinity,\n          draggable: false,\n          previousVertex: null\n        };\n        wallgrid[row][division_point] = newVertex;\n      }\n    }\n  } else {\n    for (let col = start; col < end; col++) {\n      if (\n        grid[division_point][col].isStart ||\n        grid[division_point][col].isFinish\n      )\n        continue;\n      if (col !== skip_this_cell) {\n        let vertex = wallgrid[division_point][col];\n        let newVertex = {\n          ...vertex,\n          isWall: !vertex.isWall, //changed here\n          isPath: false,\n          isVisited: false,\n          distance: Infinity,\n          distanceToThis: Infinity,\n          heuristic: Infinity,\n          draggable: false,\n          previousVertex: null\n        };\n        wallgrid[division_point][col] = newVertex;\n      }\n    }\n  }\n  return wallgrid;\n};\n\n//create a function for swapping a drid vertices\nexport const swapVertices = (grid, vertex, new_position) => {\n  const dragged_from_position = vertex.position;\n  // dropped at position\n  vertex.position = new_position;\n  grid[new_position.row][new_position.col] = vertex;\n  const empty_vertex = {\n    position: dragged_from_position,\n    isStart: false,\n    isFinish: false,\n    distance: Infinity,\n    distanceToThis: 0,\n    heuristic: 0,\n    isVisited: false,\n    isWall: false,\n    isPath: false,\n    previousVertex: null,\n    draggable: !vertex.draggable\n  };\n  grid[dragged_from_position.row][dragged_from_position.col] = empty_vertex;\n\n  vertex.distance = Infinity;\n  return grid;\n};\n\nexport const updateGrid = grid => {\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col < COLUMNS; col++) {\n      //check the vertex\n      grid[row][col].distance = Infinity;\n      grid[row][col].distanceToThis = 0;\n      grid[row][col].heuristic = 0;\n      grid[row][col].isPath = false;\n      grid[row][col].isVisited = false;\n      grid[row][col].previousVertex = null;\n    }\n  }\n  return grid;\n};\n","import React, { useEffect, useContext } from \"react\";\nimport GridContext from \"../context/grid/gridContext\";\nimport \"./PathfinderVisualizer.css\";\nimport Vertex from \"./Vertex/Vertex\";\nimport DistancePicker from \"../Components/Methods\";\n\nimport {\n  createInitialGrid,\n  createGridWithWalls,\n  swapVertices,\n  updateGrid\n} from \"./Initializers/GridInitializers\";\n\nimport { ROWS, COLUMNS } from \"../parameters\";\n\nconst PathfinderVisualizer = () => {\n  const gridContext = useContext(GridContext);\n\n  const {\n    grid,\n    setGrid,\n    setMouseIsPressed,\n    start_vertex_row,\n    start_vertex_col,\n    finish_vertex_row,\n    finish_vertex_col,\n    mouseIsPressed,\n    setStart,\n    setFinish,\n    distanceMethod,\n    allowDiagonal,\n    setDistanceMethod,\n    setAllowDiagonal,\n    algorithm,\n    setAlgorithm\n  } = gridContext;\n\n  const start_finish = {\n    start_vertex_row,\n    start_vertex_col,\n    finish_vertex_row,\n    finish_vertex_col\n  };\n\n  useEffect(() => {\n    // eslint-disable-next-line\n    setGrid(createInitialGrid(start_finish));\n  }, []);\n\n  const handleDragStart = (event, position, vertex) => {\n    const { row, col } = position;\n\n    if (\n      !(row === start_vertex_row && col === start_vertex_col) &&\n      !(row === finish_vertex_row && col === finish_vertex_col)\n    ) {\n      return;\n    } else {\n      const vertexData = JSON.stringify(vertex);\n      event.dataTransfer.setData(\"vertex_data\", vertexData);\n    }\n\n    return;\n  };\n  const handleDragOver = (event, position) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleDrop = (event, new_position) => {\n    const vertex = JSON.parse(event.dataTransfer.getData(\"vertex_data\"));\n    if (vertex.isStart || vertex.isFinish) {\n      if (\n        (new_position.row === finish_vertex_row &&\n          new_position.col === finish_vertex_col) ||\n        (new_position.row === start_vertex_row &&\n          new_position.col === start_vertex_col)\n      )\n        return;\n    }\n    // reassign the start or finish vertex depending on the vertex.isFinish \\\\ vertex.isStart\n    if (vertex.isStart) {\n      setStart(new_position);\n    } else {\n      setFinish(new_position);\n    }\n    setGrid(swapVertices(grid, vertex, new_position));\n    setGrid(updateGrid(grid));\n    event.dataTransfer.clearData();\n  };\n\n  const handleDrag = position => {\n    return;\n  };\n\n  const clearTheVisualOfVertex = () => {\n    for (let row = 0; row < ROWS; row++) {\n      for (let col = 0; col < COLUMNS; col++) {\n        let thisVertex = grid[row][col];\n        if (thisVertex.isStart)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-start\";\n        else if (thisVertex.isFinish)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-finish\";\n        else if (thisVertex.isWall)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-wall vertex-non-draggable\";\n        else {\n          document.getElementById(`vertex-${row}-${col}`).className = \"vertex \";\n        }\n      }\n    }\n  };\n\n  const handleMouseDown = position => {\n    const { row, col } = position;\n\n    if (!grid[row][col].isStart && !grid[row][col].isFinish) {\n      const wallGrid = createGridWithWalls(grid, position);\n      setGrid(wallGrid);\n      updateGrid(wallGrid);\n      setMouseIsPressed(true);\n    }\n  };\n\n  const handleMouseEnter = position => {\n    const { row, col } = position;\n    if (!mouseIsPressed) return;\n    if (!grid[row][col].isStart && !grid[row][col].isFinish) {\n      const wallGrid = createGridWithWalls(grid, position);\n      setGrid(wallGrid);\n      updateGrid(wallGrid);\n    }\n  };\n  const handleMouseUp = position => {\n    setMouseIsPressed(false);\n  };\n\n  //   const visualizeAlgorithm = () => {\n  //     clearTheVisualOfVertex();\n  //     document.getElementById(\"root\").style = \"pointer-events: none\";\n  //     document.getElementById(\"btnStart\").disabled = true;\n  //     document.getElementById(\"btnReset\").disabled = true;\n  //     for (let row = 0; row < ROWS; row++) {\n  //       for (let col = 0; col < COLUMNS; col++) {\n  //         let thisVertex = grid[row][col];\n\n  //         if (thisVertex.isStart)\n  //           document.getElementById(`vertex-${row}-${col}`).className =\n  //             \"vertex vertex-start\";\n  //         else if (thisVertex.isFinish)\n  //           document.getElementById(`vertex-${row}-${col}`).className =\n  //             \"vertex vertex-finish\";\n  //         else if (thisVertex.isWall)\n  //           document.getElementById(`vertex-${row}-${col}`).className =\n  //             \"vertex vertex-wall\";\n  //         else if (thisVertex.isVisited)\n  //           document.getElementById(`vertex-${row}-${col}`).className = \"vertex\";\n  //       }\n  //     }\n  //     const startVertex = grid[start_vertex_row][start_vertex_col];\n  //     const finishVertex = grid[finish_vertex_row][finish_vertex_col];\n  //     let visitedInOrder;\n\n  //     switch (algorithm) {\n  //       case \"astar\":\n  //         visitedInOrder = astar(grid, startVertex, finishVertex);\n  //         break;\n  //       case \"dijkstra\":\n  //         visitedInOrder = dijkstra(\n  //           grid,\n  //           startVertex,\n  //           finishVertex,\n  //           distanceMethod,\n  //           allowDiagonal\n  //         );\n  //         break;\n  //       case \"dfs\":\n  //         visitedInOrder = bfs_dfs(grid, startVertex, finishVertex, \"dfs\");\n  //         break;\n  //       case \"bfs\":\n  //         visitedInOrder = bfs_dfs(grid, startVertex, finishVertex, \"bfs\");\n  //         break;\n  //       default:\n  //         visitedInOrder = dijkstra(\n  //           grid,\n  //           startVertex,\n  //           finishVertex,\n  //           distanceMethod,\n  //           allowDiagonal\n  //         );\n  //     }\n  //     // console.log(grid);\n  //     // console.log(visitedInOrder);\n  //     const backtrackedVertices = backtrackRoute(finishVertex, startVertex);\n  //     animateAlgorithm(visitedInOrder, backtrackedVertices);\n  //   };\n\n  const chooseDiagonalMethod = event => {\n    setAllowDiagonal(event);\n    setGrid(updateGrid(grid));\n    clearTheVisualOfVertex();\n  };\n\n  const chooseDistanceMethod = event => {\n    setGrid(updateGrid(grid));\n    clearTheVisualOfVertex();\n    setDistanceMethod(event);\n  };\n  const chooseAlgorithm = event => {\n    setGrid(updateGrid(grid));\n    clearTheVisualOfVertex();\n    setAlgorithm(event);\n  };\n\n  //   const createMaze = () => {\n  //     setGrid(mazeGenerator(grid));\n  //     updateGrid(grid);\n  //   };\n  return (\n    <div>\n      <DistancePicker\n        getWhichAlgorithm={chooseAlgorithm}\n        getDistanceMethod={chooseDistanceMethod}\n        chooseDiagonal={chooseDiagonalMethod}\n      />\n      <table className=\"grid\" draggable=\"false\">\n        <tbody className=\"grid\" draggable=\"false\">\n          {grid.map((row, row_index) => {\n            return (\n              <tr className=\"row\" key={row_index}>\n                {row.map((vertex, vertex_index) => {\n                  const {\n                    position,\n                    isFinish,\n                    isStart,\n                    isWall,\n                    isVisited,\n                    isPath,\n                    distance\n                  } = vertex;\n                  return (\n                    <Vertex\n                      key={vertex_index}\n                      position={position}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      onMouseDown={position => handleMouseDown(position)}\n                      onMouseEnter={position => handleMouseEnter(position)}\n                      onMouseUp={position => handleMouseUp(position)}\n                      onDragStart={e => handleDragStart(e, position, vertex)}\n                      onDragOver={event => handleDragOver(event, position)}\n                      onDrop={event => handleDrop(event, position)}\n                      onDrag={handleDrag}\n                      mouseIsPressed={mouseIsPressed}\n                      isWall={isWall}\n                      distance={distance}\n                      isVisited={isVisited}\n                      isPath={isPath}\n                      draggable={(isStart || isFinish) && !isWall}\n                    ></Vertex>\n                  );\n                })}\n              </tr>\n            );\n          })}\n        </tbody>\n      </table>\n    </div>\n  );\n};\n\nexport default PathfinderVisualizer;\n","import { createInitialGrid } from \"../Initializers/GridInitializers\";\nimport { ROWS, COLUMNS } from \"../../parameters\";\n\nexport const resetGrid = (grid, setGrid, start_finish) => {\n  const resetGrid = createInitialGrid(start_finish);\n  setGrid(resetGrid);\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col < COLUMNS; col++) {\n      let thisVertex = grid[row][col];\n      if (thisVertex.isStart)\n        document.getElementById(`vertex-${row}-${col}`).className =\n          \"vertex vertex-start\";\n      else if (thisVertex.isFinish)\n        document.getElementById(`vertex-${row}-${col}`).className =\n          \"vertex vertex-finish\";\n      else {\n        document.getElementById(`vertex-${row}-${col}`).className = \"vertex \";\n      }\n    }\n  }\n};\n","/**\n *\n * This performs the Dijkstra algorithm returning all vertices that were\n * visited. Change the previousVertex value of the vertex to\n * backtrack from the finish vertex to the start vertex\n *\n */\nexport const dijkstra = (\n  grid,\n  start,\n  finish,\n  distanceMethod,\n  allowDiagonal\n) => {\n  const visitedInOrder = [];\n  // assign start vertex distance 0\n  // by default the vertices are infinite distance away from the start\n  start.distance = 0;\n  // get all vertices\n  const unvisitedVertices = getAllVertices(grid);\n  while (unvisitedVertices.length !== 0) {\n    getTheClosestVerticesFirst(unvisitedVertices);\n    const closestVertex = unvisitedVertices.shift();\n    console.log(\"distance of closest vertex is: \", closestVertex.distance);\n    if (closestVertex.isWall) continue;\n    if (closestVertex.distance === Infinity) return visitedInOrder;\n    updateUnvisitedNeighbors(\n      closestVertex,\n      grid,\n      distanceMethod,\n      allowDiagonal\n    );\n    closestVertex.isVisited = true;\n    visitedInOrder.push(closestVertex);\n    // before was like this :\n    // updateUnvisitedNeighbors(closestVertex, grid);\n    if (closestVertex === finish) return visitedInOrder;\n  }\n};\n\nconst getAllVertices = grid => {\n  const vertices = [];\n  for (const row of grid) for (const vertex of row) vertices.push(vertex);\n  return vertices;\n};\n\n// sort the vertices by ascending distance value\n// we can use PriorityQueue to improve on performance\nconst getTheClosestVerticesFirst = unvisitedVertices => {\n  unvisitedVertices.sort(\n    (vertexA, vertexB) => vertexA.distance - vertexB.distance\n  );\n};\n\nconst updateUnvisitedNeighbors = (\n  vertex,\n  grid,\n  distanceMethod,\n  allowDiagonal\n) => {\n  getUnvisitedNeighbors(vertex, grid, distanceMethod, allowDiagonal);\n};\n\nconst getUnvisitedNeighbors = (vertex, grid, distanceMethod, allowDiagonal) => {\n  const { row, col } = vertex.position;\n\n  if (allowDiagonal) {\n    let hVDistance, dDistance;\n    switch (distanceMethod) {\n      case \"manhattan\":\n        hVDistance = 1;\n        dDistance = 2;\n        break;\n      case \"euclidean\":\n        hVDistance = 1;\n        dDistance = 1.4;\n        break;\n      case \"chebyshev\":\n        hVDistance = 1;\n        dDistance = 1;\n        break;\n      default:\n        hVDistance = 1;\n        dDistance = 2;\n    }\n    // Top\n    let t;\n    if (row - 1 >= 0) {\n      // Top Left\n      if (col - 1 > 0) {\n        t = grid[row - 1][col - 1];\n        if (\n          !t.isVisited &&\n          !t.isWall &&\n          t.distance > vertex.distance + dDistance\n        ) {\n          t.distance = vertex.distance + dDistance;\n          t.previousVertex = vertex;\n        }\n      }\n      // Top Top\n      t = grid[row - 1][col];\n      if (\n        !t.isVisited &&\n        !t.isWall &&\n        t.distance > vertex.distance + hVDistance\n      ) {\n        t.distance = vertex.distance + hVDistance;\n        t.previousVertex = vertex;\n      }\n\n      // Top Right\n      if (col + 1 < grid[0].length) {\n        t = grid[row - 1][col + 1];\n        if (\n          !t.isVisited &&\n          !t.isWall &&\n          t.distance > vertex.distance + dDistance\n        ) {\n          t.distance = vertex.distance + dDistance;\n          t.previousVertex = vertex;\n        }\n      }\n    }\n\n    // Right\n    if (col + 1 < grid[0].length) {\n      t = grid[row][col + 1];\n      if (\n        !t.isVisited &&\n        !t.isWall &&\n        t.distance > vertex.distance + hVDistance\n      ) {\n        t.distance = vertex.distance + hVDistance;\n        t.previousVertex = vertex;\n      }\n    }\n\n    // Down\n    if (row + 1 < grid.length) {\n      // Down Right\n      if (col + 1 < grid[0].length) {\n        t = grid[row + 1][col + 1];\n        if (\n          !t.isVisited &&\n          !t.isWall &&\n          t.distance > vertex.distance + dDistance\n        ) {\n          t.distance = vertex.distance + dDistance;\n          t.previousVertex = vertex;\n        }\n      }\n      // Down Down\n      t = grid[row + 1][col];\n      if (\n        !t.isVisited &&\n        !t.isWall &&\n        t.distance > vertex.distance + hVDistance\n      ) {\n        t.distance = vertex.distance + hVDistance;\n        t.previousVertex = vertex;\n      }\n\n      // Down Left\n      if (col - 1 >= 0) {\n        t = grid[row + 1][col - 1];\n        if (\n          !t.isVisited &&\n          !t.isWall &&\n          t.distance > vertex.distance + dDistance\n        ) {\n          t.distance = vertex.distance + dDistance;\n          t.previousVertex = vertex;\n        }\n      }\n    }\n    // Left\n    if (col - 1 > 0) {\n      t = grid[row][col - 1];\n      if (\n        !t.isVisited &&\n        !t.isWall &&\n        t.distance > vertex.distance + hVDistance\n      ) {\n        t.distance = vertex.distance + hVDistance;\n        t.previousVertex = vertex;\n      }\n    }\n  } else {\n    //  non diagonal movements only\n    if (\n      row > 0 &&\n      !grid[row - 1][col].isVisited &&\n      !grid[row - 1][col].isWall\n    ) {\n      grid[row - 1][col].distance = vertex.distance + 1;\n      grid[row - 1][col].previousVertex = vertex;\n    }\n    if (\n      col < grid[0].length - 1 &&\n      !grid[row][col + 1].isVisited &&\n      !grid[row][col + 1].isWall\n    ) {\n      grid[row][col + 1].distance = vertex.distance + 1;\n      grid[row][col + 1].previousVertex = vertex;\n    }\n    if (\n      row < grid.length - 1 &&\n      !grid[row + 1][col].isVisited &&\n      !grid[row + 1][col].isWall\n    ) {\n      grid[row + 1][col].distance = vertex.distance + 1;\n      grid[row + 1][col].previousVertex = vertex;\n    }\n    if (\n      col > 0 &&\n      !grid[row][col - 1].isVisited &&\n      !grid[row][col - 1].isWall\n    ) {\n      grid[row][col - 1].distance = vertex.distance + 1;\n      grid[row][col - 1].previousVertex = vertex;\n    }\n  }\n};\n\nexport const backtrackRoute = (finish, start) => {\n  const backtrackedVertices = [];\n  let currentVertex = finish;\n  currentVertex = currentVertex.previousVertex;\n  if (currentVertex === null) return backtrackedVertices;\n  while (currentVertex !== start) {\n    currentVertex.isPath = true;\n    backtrackedVertices.unshift(currentVertex);\n    currentVertex = currentVertex.previousVertex;\n  }\n  return backtrackedVertices;\n};\n","/**\n *\n * This performs the Dijkstra algorithm returning all vertices that were\n * visited. Change the previousVertex value of the vertex to\n * backtrack from the finish vertex to the start vertex\n *\n */\nexport const astar = (grid, start, finish) => {\n  console.log(\"starting astar\");\n  const visitedInOrder = [];\n  // assign start vertex distance 0\n  // by default the vertices are infinite distance away from the start\n  start.distance = 0;\n  // get all vertices\n  const unvisitedVertices = getAllVertices(grid);\n  while (unvisitedVertices.length !== 0) {\n    getTheClosestVerticesFirst(unvisitedVertices);\n    const closestVertex = unvisitedVertices.shift();\n\n    if (closestVertex.isWall) continue;\n    if (closestVertex.distance === Infinity) return visitedInOrder;\n    updateUnvisitedNeighbors(closestVertex, grid, start, finish);\n    closestVertex.isVisited = true;\n    visitedInOrder.push(closestVertex);\n    // before was like this :\n    // updateUnvisitedNeighbors(closestVertex, grid);\n    if (closestVertex === finish) return visitedInOrder;\n  }\n};\n\nconst getAllVertices = grid => {\n  const vertices = [];\n  for (const row of grid) for (const vertex of row) vertices.push(vertex);\n  return vertices;\n};\n\n// sort the vertices by ascending distance value\n// we can use PriorityQueue to improve on performance\nconst getTheClosestVerticesFirst = unvisitedVertices => {\n  unvisitedVertices.sort(\n    (vertexA, vertexB) => vertexA.distance - vertexB.distance\n  );\n};\n\nconst updateUnvisitedNeighbors = (vertex, grid, start, finish) => {\n  getUnvisitedNeighbors(vertex, grid, start, finish);\n};\n\nconst getUnvisitedNeighbors = (vertex, grid, start, finish) => {\n  const { row, col } = vertex.position;\n\n  // Top\n  let t;\n  if (row - 1 >= 0) {\n    // Top Left\n    if (col - 1 > 0) {\n      t = grid[row - 1][col - 1];\n      let tempF =\n        vertex.distanceToThis +\n        distanceFromStartToThis(vertex, t) +\n        calculateHeuristic(t, finish);\n      if (!t.isWall && !t.isVisited) {\n        if (t.distance === Infinity || t.distance < tempF) {\n          t.distanceToThis =\n            vertex.distanceToThis + distanceFromStartToThis(t, vertex);\n          t.heuristic = calculateHeuristic(t, finish);\n          t.distance = t.distanceToThis + t.heuristic;\n          t.previousVertex = vertex;\n        } else {\n          t.distance = tempF;\n        }\n      }\n    }\n    // Top Top\n    t = grid[row - 1][col];\n    let tempF =\n      vertex.distanceToThis +\n      distanceFromStartToThis(vertex, t) +\n      calculateHeuristic(t, finish);\n    if (!t.isWall && !t.isVisited) {\n      if (t.distance === Infinity || t.distance < tempF) {\n        t.distanceToThis =\n          vertex.distanceToThis + distanceFromStartToThis(t, vertex);\n        t.heuristic = calculateHeuristic(t, finish);\n        t.distance = t.distanceToThis + t.heuristic;\n        t.previousVertex = vertex;\n      } else {\n        t.distance = tempF;\n      }\n    }\n\n    // Top Right\n    if (col + 1 < grid[0].length) {\n      t = grid[row - 1][col + 1];\n      let tempF =\n        vertex.distanceToThis +\n        distanceFromStartToThis(vertex, t) +\n        calculateHeuristic(t, finish);\n      if (!t.isWall && !t.isVisited) {\n        if (t.distance === Infinity || t.distance < tempF) {\n          t.distanceToThis =\n            vertex.distanceToThis + distanceFromStartToThis(t, vertex);\n          t.heuristic = calculateHeuristic(t, finish);\n          t.distance = t.distanceToThis + t.heuristic;\n          t.previousVertex = vertex;\n        } else {\n          t.distance = tempF;\n        }\n      }\n    }\n  }\n\n  // Right\n  if (col + 1 < grid[0].length) {\n    t = grid[row][col + 1];\n    let tempF =\n      vertex.distanceToThis +\n      distanceFromStartToThis(vertex, t) +\n      calculateHeuristic(t, finish);\n    if (!t.isWall && !t.isVisited) {\n      if (t.distance === Infinity || t.distance < tempF) {\n        t.distanceToThis =\n          vertex.distanceToThis + distanceFromStartToThis(t, vertex);\n        t.heuristic = calculateHeuristic(t, finish);\n        t.distance = t.distanceToThis + t.heuristic;\n        t.previousVertex = vertex;\n      } else {\n        t.distance = tempF;\n      }\n    }\n  }\n\n  // Down\n  if (row + 1 < grid.length) {\n    // Down Right\n    if (col + 1 < grid[0].length) {\n      t = grid[row + 1][col + 1];\n      let tempF =\n        vertex.distanceToThis +\n        distanceFromStartToThis(vertex, t) +\n        calculateHeuristic(t, finish);\n      if (!t.isWall && !t.isVisited) {\n        if (t.distance === Infinity || t.distance < tempF) {\n          t.distanceToThis =\n            vertex.distanceToThis + distanceFromStartToThis(t, vertex);\n          t.heuristic = calculateHeuristic(t, finish);\n          t.distance = t.distanceToThis + t.heuristic;\n          t.previousVertex = vertex;\n        } else {\n          t.distance = tempF;\n        }\n      }\n    }\n    // Down Down\n    t = grid[row + 1][col];\n    let tempF =\n      vertex.distanceToThis +\n      distanceFromStartToThis(vertex, t) +\n      calculateHeuristic(t, finish);\n    if (!t.isWall && !t.isVisited) {\n      if (t.distance === Infinity || t.distance < tempF) {\n        t.distanceToThis =\n          vertex.distanceToThis + distanceFromStartToThis(t, vertex);\n        t.heuristic = calculateHeuristic(t, finish);\n        t.distance = t.distanceToThis + t.heuristic;\n        t.previousVertex = vertex;\n      } else {\n        t.distance = tempF;\n      }\n    }\n\n    // Down Left\n    if (col - 1 >= 0) {\n      t = grid[row + 1][col - 1];\n      let tempF =\n        vertex.distanceToThis +\n        distanceFromStartToThis(vertex, t) +\n        calculateHeuristic(t, finish);\n      if (!t.isWall && !t.isVisited) {\n        if (t.distance === Infinity || t.distance < tempF) {\n          t.distanceToThis =\n            vertex.distanceToThis + distanceFromStartToThis(t, vertex);\n          t.heuristic = calculateHeuristic(t, finish);\n          t.distance = t.distanceToThis + t.heuristic;\n          t.previousVertex = vertex;\n        } else {\n          t.distance = tempF;\n        }\n      }\n    }\n  }\n  // Left\n  if (col - 1 > 0) {\n    t = grid[row][col - 1];\n    let tempF =\n      vertex.distanceToThis +\n      distanceFromStartToThis(vertex, t) +\n      calculateHeuristic(t, finish);\n    if (!t.isWall && !t.isVisited) {\n      if (t.distance === Infinity || t.distance < tempF) {\n        t.distanceToThis =\n          vertex.distanceToThis + distanceFromStartToThis(t, vertex);\n        t.heuristic = calculateHeuristic(t, finish);\n        t.distance = t.distanceToThis + t.heuristic;\n        t.previousVertex = vertex;\n      } else {\n        t.distance = tempF;\n      }\n    }\n  }\n};\n\nexport const backtrackRoute = (finish, start) => {\n  const backtrackedVertices = [];\n  let currentVertex = finish;\n  //   currentVertex = currentVertex.previousVertex;\n  if (currentVertex === null) return backtrackedVertices;\n  while (currentVertex !== start) {\n    currentVertex.isPath = true;\n    backtrackedVertices.unshift(currentVertex);\n    currentVertex = currentVertex.previousVertex;\n  }\n  return backtrackedVertices;\n};\n\nconst calculateHeuristic = (from, to) =>\n  EuclideanDistance(from.position, to.position);\n\nconst distanceFromStartToThis = (from, to) => {\n  return EuclideanDistance(from.position, to.position);\n};\n\n// function ManhattanDistance(Point, Goal) {\n//   // linear movement - no diagonals - just cardinal directions (NSEW)\n//   return Math.abs(Point.row - Goal.row) + Math.abs(Point.col - Goal.col);\n// }\n\n// function DiagonalDistance(Point, Goal) {\n//   // diagonal movement - assumes diag dist is 1, same as cardinals\n//   return Math.max(\n//     Math.abs(Point.row - Goal.row),\n//     Math.abs(Point.col - Goal.col)\n//   );\n// }\n\nfunction EuclideanDistance(Point, Goal) {\n  return Math.sqrt(\n    Math.pow(Point.row - Goal.row, 2) + Math.pow(Point.col - Goal.col, 2)\n  );\n}\n\n/**\n *\n * Use onlu one Heuristic approach for solving the Astart algorithm\n * USE EUCLIDEAN DISTANCE HEURISTICS\n */\n","export const animateShortestPath = backtrackRoute => {\n  for (let i = 0; i < backtrackRoute.length; i++) {\n    setTimeout(() => {\n      const vertex = backtrackRoute[i];\n      document.getElementById(\n        `vertex-${vertex.position.row}-${vertex.position.col}`\n      ).className = \"vertex vertex-shortest-path\";\n    }, 40 * i);\n  }\n  document.getElementById(\"btnStart\").disabled = false;\n  document.getElementById(\"btnReset\").disabled = false;\n  document.getElementById(\"root\").style = \"pointer-events: initial\";\n};\n\nexport const animateAlgorithm = (visitedInOrder, backtrackedVertices) => {\n  for (let i = 0; i <= visitedInOrder.length; i++) {\n    if (i === visitedInOrder.length) {\n      setTimeout(() => {\n        animateShortestPath(backtrackedVertices);\n      }, 40 * i);\n      return;\n    }\n    setTimeout(() => {\n      const row = visitedInOrder[i].position.row;\n      const col = visitedInOrder[i].position.col;\n      const isStart = visitedInOrder[i].isStart;\n      const isFinish = visitedInOrder[i].isFinish;\n\n      if (!(isStart || isFinish))\n        document.getElementById(`vertex-${row}-${col}`).className =\n          \"vertex vertex-visited\";\n    }, 40 * i);\n  }\n};\n","export const bfs_dfs = (grid, start, finish, algorithm) => {\n  if (!start || !finish || start === finish) return [];\n  let visitedInOrder = [];\n  console.log(start);\n  let structure = [];\n  structure.push(start);\n  console.log(structure);\n  let currentVertex;\n  let neighbors = [];\n\n  //  dfs\n  if (algorithm === \"dfs\") {\n    while (structure.length) {\n      currentVertex = structure.pop();\n      console.log(\"i am doing dfs\");\n      currentVertex.isVisited = true;\n\n      if (currentVertex === finish) return visitedInOrder;\n      visitedInOrder.push(currentVertex);\n      neighbors = getNeighbors(grid, currentVertex);\n      console.log(`Neighbors lsit is : ${neighbors}`);\n      neighbors.forEach(neighbor => {\n        if (!neighbor.isVisited) {\n          neighbor.previousVertex = currentVertex;\n          structure.push(neighbor);\n        }\n      });\n    }\n  } else {\n    while (structure.length) {\n      currentVertex = structure.shift();\n      //   if (!currentVertex.isVisited) {\n      currentVertex.isVisited = true;\n      if (currentVertex === finish) return visitedInOrder;\n      neighbors = getNeighbors(grid, currentVertex);\n      visitedInOrder.push(currentVertex);\n      neighbors.forEach(neighbor => {\n        if (neighbor.isVisited === false) {\n          neighbor.previousVertex = currentVertex;\n          console.log(\"pushed neighbor is\", neighbor);\n          structure.push(neighbor);\n          neighbor.isVisited = true;\n        } else {\n          console.log(\"neighbor is visited\");\n        }\n      });\n      //   }\n    }\n  }\n  return visitedInOrder;\n};\n\nconst getNeighbors = (grid, vertex) => {\n  const { row, col } = vertex.position;\n  const neighbors = [];\n  if (row > 0 && !grid[row - 1][col].isWall && !grid[row - 1][col].isVisited)\n    neighbors.push(grid[row - 1][col]);\n  if (\n    col < grid[0].length - 1 &&\n    !grid[row][col + 1].isWall &&\n    !grid[row][col + 1].isVisited\n  )\n    neighbors.push(grid[row][col + 1]);\n  if (\n    row < grid.length - 1 &&\n    !grid[row + 1][col].isWall &&\n    !grid[row + 1][col].isVisited\n  )\n    neighbors.push(grid[row + 1][col]);\n  if (col > 0 && !grid[row][col - 1].isWall && !grid[row][col - 1].isVisited)\n    neighbors.push(grid[row][col - 1]);\n\n  return neighbors;\n};\n","import React, { useContext } from \"react\";\nimport \"./navbar.scss\";\nimport { resetGrid } from \"../PathfinderVisualizer/Initializers/GridReset\";\nimport GridContext from \"../context/grid/gridContext\";\nimport { dijkstra, backtrackRoute } from \"../algorithms/dijkstra\";\nimport { astar } from \"../algorithms/astar\";\nimport { animateAlgorithm } from \"../PathfinderVisualizer/Visualizers/Visualize\";\nimport { bfs_dfs } from \"../algorithms/bfs_dfs\";\nimport { ROWS, COLUMNS } from \"../parameters\";\n\nfunction Navbar() {\n  const gridContext = useContext(GridContext);\n\n  const {\n    grid,\n    setGrid,\n\n    start_vertex_row,\n    start_vertex_col,\n    finish_vertex_row,\n    finish_vertex_col,\n\n    distanceMethod,\n    allowDiagonal,\n\n    algorithm\n  } = gridContext;\n\n  const start_finish = {\n    start_vertex_row,\n    start_vertex_col,\n    finish_vertex_row,\n    finish_vertex_col\n  };\n\n  const clearTheVisualOfVertex = () => {\n    for (let row = 0; row < ROWS; row++) {\n      for (let col = 0; col < COLUMNS; col++) {\n        let thisVertex = grid[row][col];\n        if (thisVertex.isStart)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-start\";\n        else if (thisVertex.isFinish)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-finish\";\n        else if (thisVertex.isWall)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-wall vertex-non-draggable\";\n        else {\n          document.getElementById(`vertex-${row}-${col}`).className = \"vertex \";\n        }\n      }\n    }\n  };\n\n  const visualizeAlgorithm = () => {\n    clearTheVisualOfVertex();\n    document.getElementById(\"root\").style = \"pointer-events: none\";\n    document.getElementById(\"btnStart\").disabled = true;\n    document.getElementById(\"btnReset\").disabled = true;\n    for (let row = 0; row < ROWS; row++) {\n      for (let col = 0; col < COLUMNS; col++) {\n        let thisVertex = grid[row][col];\n\n        if (thisVertex.isStart)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-start\";\n        else if (thisVertex.isFinish)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-finish\";\n        else if (thisVertex.isWall)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-wall\";\n        else if (thisVertex.isVisited)\n          document.getElementById(`vertex-${row}-${col}`).className = \"vertex\";\n      }\n    }\n    const startVertex = grid[start_vertex_row][start_vertex_col];\n    const finishVertex = grid[finish_vertex_row][finish_vertex_col];\n    let visitedInOrder;\n\n    switch (algorithm) {\n      case \"astar\":\n        visitedInOrder = astar(grid, startVertex, finishVertex);\n        break;\n      case \"dijkstra\":\n        visitedInOrder = dijkstra(\n          grid,\n          startVertex,\n          finishVertex,\n          distanceMethod,\n          allowDiagonal\n        );\n        break;\n      case \"dfs\":\n        visitedInOrder = bfs_dfs(grid, startVertex, finishVertex, \"dfs\");\n        break;\n      case \"bfs\":\n        visitedInOrder = bfs_dfs(grid, startVertex, finishVertex, \"bfs\");\n        break;\n      default:\n        visitedInOrder = dijkstra(\n          grid,\n          startVertex,\n          finishVertex,\n          distanceMethod,\n          allowDiagonal\n        );\n    }\n    // console.log(grid);\n    // console.log(visitedInOrder);\n    const backtrackedVertices = backtrackRoute(finishVertex, startVertex);\n    animateAlgorithm(visitedInOrder, backtrackedVertices);\n  };\n\n  return (\n    <div className=\"container\">\n      <h2>Pathfinder Algorithms Visualization</h2>\n\n      <nav className=\"main-nav\">\n        <div className=\"algorithms-methods\">\n          <h1>something</h1>\n        </div>\n        <div className=\"buttons\">\n          <button\n            id=\"btnStart\"\n            className=\"btn\"\n            onClick={() => visualizeAlgorithm()}\n          >\n            Start\n          </button>\n          <button\n            id=\"btnReset\"\n            className=\"btn\"\n            onClick={() => resetGrid(grid, setGrid, start_finish)}\n          >\n            Reset Grid\n          </button>\n        </div>\n      </nav>\n    </div>\n  );\n}\n\nexport default Navbar;\n","import React from \"react\";\nimport \"./App.css\";\nimport GridState from \"./context/grid/GridState\";\nimport PathfinderVisualizer from \"./PathfinderVisualizer/PathfinderVisualizer\";\nimport Navbar from \"./Components/Navbar\";\n\nfunction App() {\n  return (\n    <GridState>\n      <div className=\"App\" draggable=\"false\">\n        <Navbar />\n\n        <PathfinderVisualizer />\n      </div>\n    </GridState>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}