{"version":3,"sources":["context/grid/gridContext.js","context/grid/gridReducer.js","context/types.js","parameters.js","context/grid/GridState.js","algorithms/dijkstra.js","PathfinderVisualizer/Vertex/Vertex.js","PathfinderVisualizer/Initializers/GridInitializers.js","PathfinderVisualizer/PathfinderVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["GridContext","createContext","state","action","type","grid","payload","start_vertex_row","start_vertex_col","finish_vertex_row","finish_vertex_col","mouseIsPressed","isDragging","original_row","original_col","translate_row","translate_col","last_translate_row","last_translate_col","ROWS","COLUMNS","window","innerWidth","GridState","props","initialState","useReducer","gridReducer","dispatch","Provider","value","setGrid","setStart","position","row","col","setFinish","setMouseIsPressed","pressed","setIsDragging","started_dragging","setOriginal","setTranslate","setLastTranslate","children","dijkstra","start","finish","visitedInOrder","distance","unvisitedVertices","getAllVertices","length","getTheClosestVerticesFirst","closestVertex","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbors","vertices","vertex","sort","vertexA","vertexB","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousVertex","neighbors","filter","backtrackRoute","backtrackedVertices","currentVertex","isPath","unshift","Vertex","isFinish","isStart","onMouseDown","onMouseEnter","onMouseUp","onDragStart","onDragOver","onDrop","draggable","extraClassName","id","className","createInitialGrid","start_finish","thisRow","createVertex","createGridWithWalls","wallGrid","console","log","newVertex","updateGrid","PathfinderVisualizer","gridContext","useContext","useEffect","handleDragOver","event","preventDefault","handleDrag","clearTheVisualOfVertex","thisVertex","document","getElementById","animateAlgorithm","i","setTimeout","disabled","animateShortestPath","onClick","startVertex","finishVertex","visualizeAlgorithm","resetGrid","map","row_index","key","vertex_index","handleMouseDown","handleMouseEnter","e","vertexData","JSON","stringify","dataTransfer","setData","handleDragStart","new_position","parse","getData","dragged_from_position","empty_vertex","swapVertices","clearData","handleDrop","onDrag","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.bb01df53.chunk.js","sourcesContent":["import { createContext } from \"react\";\n\nconst GridContext = createContext();\n\nexport default GridContext;\n","/**\n *\n * Deleted all the get actions, because triggering the data\n * does not happen in the reducer. Only setting the state values happen\n * in reducer.\n * State values can be retrieved inside the functional component itself.\n *\n */\n\nimport {\n  SET_GRID,\n  SET_STARTING_ROW,\n  SET_STARTING_COL,\n  SET_FINISH_ROW,\n  SET_FINISH_COL,\n  SET_MOUSE_IS_PRESSED,\n  IS_DRAGGING,\n  SET_ORIGINAL_ROW,\n  SET_ORIGINAL_COL,\n  SET_TRANSLATE_ROW,\n  SET_TRANSLATE_COL,\n  SET_LAST_TRANSLATE_ROW,\n  SET_LAST_TRANSLATE_COL\n} from \"../types.js\";\n\nexport default (state, action) => {\n  switch (action.type) {\n    case SET_GRID:\n      return { ...state, grid: action.payload };\n\n    case SET_STARTING_ROW:\n      return { ...state, start_vertex_row: action.payload };\n\n    case SET_STARTING_COL:\n      return { ...state, start_vertex_col: action.payload };\n\n    case SET_FINISH_ROW:\n      return { ...state, finish_vertex_row: action.payload };\n\n    case SET_FINISH_COL:\n      return { ...state, finish_vertex_col: action.payload };\n\n    case SET_MOUSE_IS_PRESSED:\n      return { ...state, mouseIsPressed: action.payload };\n    // related to dragging :\n    case IS_DRAGGING:\n      return { ...state, isDragging: action.payload };\n\n    case SET_ORIGINAL_ROW:\n      return { ...state, original_row: action.payload };\n\n    case SET_ORIGINAL_COL:\n      return { ...state, original_col: action.payload };\n\n    case SET_TRANSLATE_ROW:\n      return { ...state, translate_row: action.payload };\n\n    case SET_TRANSLATE_COL:\n      return { ...state, translate_col: action.payload };\n\n    case SET_LAST_TRANSLATE_ROW:\n      return { ...state, last_translate_row: action.payload };\n\n    case SET_LAST_TRANSLATE_COL:\n      return { ...state, last_translate_col: action.payload };\n\n    default:\n      return state;\n  }\n};\n","export const SET_GRID = \"SET_GRID\";\nexport const SET_STARTING_ROW = \"SET_STARTING_ROW\";\nexport const SET_STARTING_COL = \"SET_STARTING_COL\";\nexport const SET_FINISH_ROW = \"SET_FINISH_ROW\";\nexport const SET_FINISH_COL = \"SET_FINISH_COL\";\n\nexport const SET_MOUSE_IS_PRESSED = \"SET_MOUSE_IS_PRESSED\";\n\nexport const IS_DRAGGING = \"IS_DRAGGING\";\n\nexport const SET_ORIGINAL_ROW = \"SET_ORIGINAL_ROW\";\nexport const SET_ORIGINAL_COL = \"SET_ORIGINAL_COL\";\n\nexport const SET_TRANSLATE_ROW = \"SET_TRANSLATE_ROW\";\nexport const SET_TRANSLATE_COL = \"SET_TRANSLATE_COL\";\n\nexport const SET_LAST_TRANSLATE_ROW = \"SET_LAST_TRANSLATE_ROW\";\nexport const SET_LAST_TRANSLATE_COL = \"SET_LAST_TRANSLATE_COL\";\n","export const ROWS = 20;\nexport const COLUMNS = window.innerWidth / 35;\nexport const FAST = 10;\nexport const MEDIUM = 40;\nexport const SLOW = 80;\nexport const speed = SLOW;\n\n// the following attributes will be dependent on the user\nexport const START_VERTEX_ROW_ = 1;\nexport const START_VERTEX_COL_ = 1;\nexport const FINISH_VERTEX_ROW_ = 3;\nexport const FINISH_VERTEX_COL_ = 3;\n","import React, { useReducer } from \"react\";\nimport gridContext from \"./gridContext\";\nimport gridReducer from \"./gridReducer\";\n\nimport {\n  START_VERTEX_ROW_,\n  START_VERTEX_COL_,\n  FINISH_VERTEX_ROW_,\n  FINISH_VERTEX_COL_\n} from \"../../parameters\";\n\nimport {\n  SET_GRID,\n  SET_STARTING_ROW,\n  SET_STARTING_COL,\n  SET_FINISH_ROW,\n  SET_FINISH_COL,\n  SET_MOUSE_IS_PRESSED,\n  IS_DRAGGING,\n  SET_ORIGINAL_ROW,\n  SET_ORIGINAL_COL,\n  SET_TRANSLATE_ROW,\n  SET_TRANSLATE_COL,\n  SET_LAST_TRANSLATE_ROW,\n  SET_LAST_TRANSLATE_COL\n} from \"../types.js\";\n\n/**\n * Need to update :\n * 1. Start/Finish\n * 2. Grid\n * 3. Grid with walls\n * 4. mouseIsPressed\n * 5. isDragging\n *\n */\nconst GridState = props => {\n  const initialState = {\n    grid: [],\n\n    mouseIsPressed: false,\n\n    start_vertex_row: START_VERTEX_ROW_,\n    start_vertex_col: START_VERTEX_COL_,\n    finish_vertex_row: FINISH_VERTEX_ROW_,\n    finish_vertex_col: FINISH_VERTEX_COL_,\n\n    isDragging: false,\n\n    original_row: 0,\n    original_col: 0,\n\n    translate_row: 0,\n    translate_col: 0,\n\n    last_translate_row: 0,\n    last_translate_col: 0\n  };\n\n  const [state, dispatch] = useReducer(gridReducer, initialState);\n\n  const setGrid = grid => {\n    dispatch({ type: SET_GRID, payload: grid });\n  };\n\n  const setStart = position => {\n    dispatch({ type: SET_STARTING_ROW, payload: position.row });\n    dispatch({ type: SET_STARTING_COL, payload: position.col });\n  };\n\n  const setFinish = position => {\n    dispatch({ type: SET_FINISH_ROW, payload: position.row });\n    dispatch({ type: SET_FINISH_COL, payload: position.col });\n  };\n\n  const setMouseIsPressed = pressed => {\n    dispatch({ type: SET_MOUSE_IS_PRESSED, payload: pressed });\n  };\n\n  //   for dragging actions\n  const setIsDragging = started_dragging => {\n    dispatch({ type: IS_DRAGGING, payload: started_dragging });\n  };\n\n  const setOriginal = position => {\n    dispatch({ type: SET_ORIGINAL_ROW, payload: position.row });\n    dispatch({ type: SET_ORIGINAL_COL, payload: position.col });\n  };\n\n  const setTranslate = position => {\n    dispatch({ type: SET_TRANSLATE_ROW, payload: position.row });\n    dispatch({ type: SET_TRANSLATE_COL, payload: position.col });\n  };\n\n  const setLastTranslate = position => {\n    dispatch({ type: SET_LAST_TRANSLATE_ROW, payload: position.row });\n    dispatch({ type: SET_LAST_TRANSLATE_COL, payload: position.col });\n  };\n\n  return (\n    <gridContext.Provider\n      value={{\n        grid: state.grid,\n        setGrid,\n        setStart,\n        setFinish,\n        setMouseIsPressed,\n        setIsDragging,\n        setOriginal,\n        setTranslate,\n        setLastTranslate,\n        mouseIsPressed: state.mouseIsPressed,\n        start_vertex_row: state.start_vertex_row,\n        start_vertex_col: state.start_vertex_col,\n        finish_vertex_row: state.finish_vertex_row,\n        finish_vertex_col: state.finish_vertex_col,\n        isDragging: state.isDragging,\n        original_row: state.original_row,\n        original_col: state.original_col,\n        translate_row: state.translate_row,\n        translate_col: state.translate_col,\n        last_translate_row: state.last_translate_row,\n        last_translate_col: state.last_translate_col\n      }}\n    >\n      {props.children}\n    </gridContext.Provider>\n  );\n};\n/**\n * ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n * this is where we return the state variables\n */\n\nexport default GridState;\n","/**\n *\n * This performs the Dijkstra algorithm returning all vertices that were\n * visited. Change the previousVertex value of the vertex to\n * backtrack from the finish vertex to the start vertex\n *\n */\nexport const dijkstra = (grid, start, finish) => {\n  const visitedInOrder = [];\n  // assign start vertex distance 0\n  // by default the vertices are infinite distance away from the start\n  start.distance = 0;\n  // get all vertices\n  const unvisitedVertices = getAllVertices(grid);\n  while (unvisitedVertices.length !== 0) {\n    getTheClosestVerticesFirst(unvisitedVertices);\n    const closestVertex = unvisitedVertices.shift();\n\n    if (closestVertex.isWall) continue;\n    if (closestVertex.distance === Infinity) return visitedInOrder;\n    closestVertex.isVisited = true;\n    visitedInOrder.push(closestVertex);\n    if (closestVertex === finish) return visitedInOrder;\n    updateUnvisitedNeighbors(closestVertex, grid);\n  }\n};\n\nconst getAllVertices = grid => {\n  const vertices = [];\n  for (const row of grid) for (const vertex of row) vertices.push(vertex);\n  return vertices;\n};\n\n// sort the vertices by ascending distance value\nconst getTheClosestVerticesFirst = unvisitedVertices => {\n  unvisitedVertices.sort(\n    (vertexA, vertexB) => vertexA.distance - vertexB.distance\n  );\n};\n\nconst updateUnvisitedNeighbors = (vertex, grid) => {\n  const unvisitedNeighbors = getUnvisitedNeighbors(vertex, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = vertex.distance + 1;\n    neighbor.previousVertex = vertex;\n  }\n};\n\nconst getUnvisitedNeighbors = (vertex, grid) => {\n  const neighbors = [];\n  const { row, col } = vertex.position;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n};\n\nexport const backtrackRoute = (finish, start) => {\n  const backtrackedVertices = [];\n  let currentVertex = finish;\n  currentVertex = currentVertex.previousVertex;\n  if (currentVertex === null) return backtrackedVertices;\n  while (currentVertex !== start) {\n    currentVertex.isPath = true;\n    backtrackedVertices.unshift(currentVertex);\n    currentVertex = currentVertex.previousVertex;\n  }\n  return backtrackedVertices;\n};\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport \"./Vertex.css\";\n\nconst Vertex = props => {\n  const {\n    position,\n    isFinish,\n    isStart,\n    isWall,\n    onMouseDown,\n    onMouseEnter,\n    onMouseUp,\n    isVisited,\n    isPath,\n    onDragStart,\n    onDragOver,\n    onDrop,\n    draggable\n    // onDrag\n  } = props;\n  const extraClassName = isFinish\n    ? \"vertex-finish\"\n    : isStart\n    ? \"vertex-start\"\n    : isWall\n    ? \"vertex-wall vertex-non-draggable\"\n    : isPath\n    ? \"vertex-shortest-path vertex-non-draggable\"\n    : isVisited\n    ? \"vertex-visited vertex-non-draggable\"\n    : \"\";\n\n  return (\n    <td\n      id={`vertex-${position.row}-${position.col}`}\n      className={`vertex ${extraClassName}`}\n      onMouseDown={() => onMouseDown(position)}\n      onMouseEnter={() => onMouseEnter(position)}\n      onMouseUp={() => onMouseUp(position)}\n      onDragStart={onDragStart}\n      onDragOver={onDragOver}\n      onDrop={onDrop}\n      draggable={draggable}\n      //   onDrag={() => onDrag(position)}\n    >\n      {isStart ? \"s\" : isFinish ? \"f\" : \"\"}\n    </td>\n  );\n};\n\nVertex.propTypes = {\n  position: PropTypes.object,\n  isFinish: PropTypes.bool,\n  isStart: PropTypes.bool,\n  isWall: PropTypes.bool,\n  onMouseDown: PropTypes.func,\n  onMouseUp: PropTypes.func,\n  onMouseEnter: PropTypes.func,\n  mouseIsPressed: PropTypes.bool\n};\n\nexport default Vertex;\n","import { ROWS, COLUMNS } from \"../../parameters\";\n\nexport const createInitialGrid = start_finish => {\n  const grid = [];\n  for (let row = 0; row < ROWS; row++) {\n    const thisRow = [];\n    for (let col = 0; col < COLUMNS; col++) {\n      thisRow.push(createVertex({ row, col }, start_finish));\n    }\n    grid.push(thisRow);\n  }\n  return grid;\n};\n\nconst createVertex = (position, start_finish) => {\n  const {\n    start_vertex_row,\n    start_vertex_col,\n    finish_vertex_row,\n    finish_vertex_col\n  } = start_finish;\n  return {\n    position,\n    isStart:\n      position.row === start_vertex_row && position.col === start_vertex_col,\n    isFinish:\n      position.row === finish_vertex_row && position.col === finish_vertex_col,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    isPath: false,\n    previousVertex: null,\n    draggable:\n      (position.row === start_vertex_row &&\n        position.col === start_vertex_col) ||\n      (position.row === finish_vertex_row && position.col === finish_vertex_col)\n  };\n};\n\nexport const createGridWithWalls = (grid, position) => {\n  const wallGrid = [...grid];\n  const vertex = wallGrid[position.row][position.col];\n  console.log(\"setting a new walled grid\");\n  const newVertex = {\n    ...vertex,\n    isWall: !vertex.isWall, //changed here\n    isPath: false,\n    isVisited: false,\n    distance: Infinity,\n    draggable: false,\n    previousVertex: null\n  };\n  wallGrid[position.row][position.col] = newVertex;\n  return wallGrid;\n};\n\n//create a function for swapping a drid vertices\nexport const swapVertices = (grid, vertex, new_position) => {\n  const dragged_from_position = vertex.position;\n  // dropped at position\n  vertex.position = new_position;\n  grid[new_position.row][new_position.col] = vertex;\n  const empty_vertex = {\n    position: dragged_from_position,\n    isStart: false,\n    isFinish: false,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    isPath: false,\n    previousVertex: null,\n    draggable: !vertex.draggable\n  };\n  grid[dragged_from_position.row][dragged_from_position.col] = empty_vertex;\n\n  vertex.distance = Infinity;\n  return grid;\n};\n\nexport const updateGrid = grid => {\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col < COLUMNS; col++) {\n      //check the vertex\n      grid[row][col].distance = Infinity;\n      grid[row][col].isPath = false;\n      grid[row][col].isVisited = false;\n      grid[row][col].previousVertex = null;\n    }\n  }\n  return grid;\n};\n\n// need to handle move of the finish vertex\n// implement live update of the shortest path when either end or start\n// debug the walls placed after the move was done\n","import React, { useEffect, useContext, useState } from \"react\";\nimport { dijkstra, backtrackRoute } from \"../algorithms/dijkstra\";\nimport GridContext from \"../context/grid/gridContext\";\nimport \"./PathfinderVisualizer.css\";\nimport Vertex from \"./Vertex/Vertex\";\n\nimport {\n  createInitialGrid,\n  createGridWithWalls,\n  swapVertices,\n  updateGrid\n} from \"./Initializers/GridInitializers\";\n\nimport { ROWS, COLUMNS } from \"../parameters\";\nimport { cloneWithoutLoc } from \"@babel/types\";\n\nconst PathfinderVisualizer = () => {\n  const gridContext = useContext(GridContext);\n\n  const {\n    grid,\n    setGrid,\n    setMouseIsPressed,\n    start_vertex_row,\n    start_vertex_col,\n    finish_vertex_row,\n    finish_vertex_col,\n    mouseIsPressed,\n    setIsDragging,\n    isDragging,\n    setOriginal,\n    original_row,\n    original_col,\n    setStart,\n    setFinish\n  } = gridContext;\n\n  const start_finish = {\n    start_vertex_row,\n    start_vertex_col,\n    finish_vertex_row,\n    finish_vertex_col\n  };\n\n  useEffect(() => {\n    // eslint-disable-next-line\n    setGrid(createInitialGrid(start_finish));\n  }, []);\n\n  const handleDragStart = (event, position, vertex) => {\n    const { row, col } = position;\n\n    if (\n      !(row === start_vertex_row && col === start_vertex_col) &&\n      !(row === finish_vertex_row && col === finish_vertex_col)\n    ) {\n      return;\n    } else {\n      const vertexData = JSON.stringify(vertex);\n      event.dataTransfer.setData(\"vertex_data\", vertexData);\n    }\n\n    return;\n  };\n  const handleDragOver = event => {\n    event.preventDefault();\n  };\n\n  const handleDrop = (event, new_position) => {\n    const vertex = JSON.parse(event.dataTransfer.getData(\"vertex_data\"));\n    if (vertex.isStart || vertex.isFinish) {\n      if (\n        (new_position.row === finish_vertex_row &&\n          new_position.col === finish_vertex_col) ||\n        (new_position.row === start_vertex_row &&\n          new_position.col === start_vertex_col)\n      )\n        return;\n    }\n    // reassign the start or finish vertex depending on the vertex.isFinish \\\\ vertex.isStart\n    if (vertex.isStart) {\n      setStart(new_position);\n    } else {\n      setFinish(new_position);\n    }\n    setGrid(swapVertices(grid, vertex, new_position));\n    setGrid(updateGrid(grid));\n    clearTheVisualOfVertex();\n    event.dataTransfer.clearData();\n  };\n\n  const handleDrag = position => {\n    return;\n  };\n\n  const clearTheVisualOfVertex = () => {\n    for (let row = 0; row < ROWS; row++) {\n      for (let col = 0; col < COLUMNS; col++) {\n        let thisVertex = grid[row][col];\n        if (thisVertex.isStart)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-start\";\n        else if (thisVertex.isFinish)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-finish\";\n        else if (thisVertex.isWall)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-wall vertex-non-draggable\";\n        else {\n          document.getElementById(`vertex-${row}-${col}`).className = \"vertex \";\n        }\n      }\n    }\n  };\n\n  const handleMouseDown = position => {\n    const { row, col } = position;\n\n    if (!grid[row][col].isStart && !grid[row][col].isFinish) {\n      const wallGrid = createGridWithWalls(grid, position);\n\n      setGrid(wallGrid);\n      updateGrid(wallGrid);\n      setMouseIsPressed(true);\n      clearTheVisualOfVertex();\n    }\n  };\n\n  const handleMouseEnter = position => {\n    const { row, col } = position;\n    if (!mouseIsPressed) return;\n    if (!grid[row][col].isStart && !grid[row][col].isFinish) {\n      const wallGrid = createGridWithWalls(grid, position);\n      setGrid(wallGrid);\n      updateGrid(wallGrid);\n      clearTheVisualOfVertex();\n    }\n  };\n  const handleMouseUp = position => {\n    setMouseIsPressed(false);\n  };\n\n  const resetGrid = () => {\n    const resetGrid = createInitialGrid(start_finish);\n    setGrid(resetGrid);\n    for (let row = 0; row < ROWS; row++) {\n      for (let col = 0; col < COLUMNS; col++) {\n        let thisVertex = grid[row][col];\n        if (thisVertex.isStart)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-start\";\n        else if (thisVertex.isFinish)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-finish\";\n        else {\n          document.getElementById(`vertex-${row}-${col}`).className = \"vertex \";\n        }\n      }\n    }\n  };\n\n  const animateShortestPath = backtrackRoute => {\n    for (let i = 0; i < backtrackRoute.length; i++) {\n      setTimeout(() => {\n        const vertex = backtrackRoute[i];\n        document.getElementById(\n          `vertex-${vertex.position.row}-${vertex.position.col}`\n        ).className = \"vertex vertex-shortest-path\";\n      }, 35 * i);\n    }\n    document.getElementById(\"btnStart\").disabled = false;\n    document.getElementById(\"btnReset\").disabled = false;\n  };\n\n  const animateAlgorithm = (visitedInOrder, backtrackedVertices) => {\n    for (let i = 0; i <= visitedInOrder.length; i++) {\n      if (i === visitedInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(backtrackedVertices);\n        }, 35 * i);\n        return;\n      }\n      setTimeout(() => {\n        const row = visitedInOrder[i].position.row;\n        const col = visitedInOrder[i].position.col;\n        const isStart = visitedInOrder[i].isStart;\n        const isFinish = visitedInOrder[i].isFinish;\n\n        if (!(isStart || isFinish))\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-visited\";\n      }, 35 * i);\n    }\n  };\n\n  function visualizeAlgorithm() {\n    document.getElementById(\"btnStart\").disabled = true;\n    document.getElementById(\"btnReset\").disabled = true;\n    for (let row = 0; row < ROWS; row++) {\n      for (let col = 0; col < COLUMNS; col++) {\n        let thisVertex = grid[row][col];\n\n        if (thisVertex.isStart)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-start\";\n        else if (thisVertex.isFinish)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-finish\";\n        else if (thisVertex.isWall)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-wall\";\n        else if (thisVertex.isVisited)\n          document.getElementById(`vertex-${row}-${col}`).className = \"vertex\";\n      }\n    }\n\n    const startVertex = grid[start_vertex_row][start_vertex_col];\n    const finishVertex = grid[finish_vertex_row][finish_vertex_col];\n    const visitedInOrder = dijkstra(grid, startVertex, finishVertex);\n    const backtrackedVertices = backtrackRoute(finishVertex, startVertex);\n    animateAlgorithm(visitedInOrder, backtrackedVertices);\n  }\n\n  return (\n    <>\n      <div>\n        {\" \"}\n        <button\n          id=\"btnStart\"\n          className=\"start\"\n          onClick={() => visualizeAlgorithm()}\n        >\n          Start\n        </button>\n        <button id=\"btnReset\" className=\"reset\" onClick={() => resetGrid()}>\n          Reset Grid\n        </button>\n      </div>\n\n      <table className=\"grid\">\n        <tbody className=\"grid\">\n          {grid.map((row, row_index) => {\n            return (\n              <tr className=\"row\" key={row_index}>\n                {row.map((vertex, vertex_index) => {\n                  const {\n                    position,\n                    isFinish,\n                    isStart,\n                    isWall,\n                    distance,\n                    isVisited,\n                    isPath,\n                    draggable\n                  } = vertex;\n                  return (\n                    <Vertex\n                      key={vertex_index}\n                      position={position}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      onMouseDown={position => handleMouseDown(position)}\n                      onMouseEnter={position => handleMouseEnter(position)}\n                      onMouseUp={position => handleMouseUp(position)}\n                      onDragStart={e => handleDragStart(e, position, vertex)}\n                      onDragOver={handleDragOver}\n                      onDrop={event => handleDrop(event, position)}\n                      onDrag={handleDrag}\n                      mouseIsPressed={mouseIsPressed}\n                      isWall={isWall}\n                      distance={distance}\n                      isVisited={isVisited}\n                      isPath={isPath}\n                      draggable={isStart || isFinish}\n                    ></Vertex>\n                  );\n                })}\n              </tr>\n            );\n          })}\n        </tbody>\n      </table>\n    </>\n  );\n};\n\nexport default PathfinderVisualizer;\n","import React from \"react\";\nimport \"./App.css\";\nimport GridState from \"./context/grid/GridState\";\nimport PathfinderVisualizer from \"./PathfinderVisualizer/PathfinderVisualizer\";\n\nfunction App() {\n  return (\n    <GridState>\n      <div className=\"App\">\n        <h1>Pathfinder visualization</h1>\n        <PathfinderVisualizer />\n      </div>\n    </GridState>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}