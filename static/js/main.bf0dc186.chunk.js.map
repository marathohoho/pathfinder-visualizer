{"version":3,"sources":["context/grid/gridContext.js","context/grid/gridReducer.js","context/types.js","parameters.js","context/grid/GridState.js","PathfinderVisualizer/Vertex/Vertex.js","Components/Methods.js","PathfinderVisualizer/Initializers/GridInitializers.js","PathfinderVisualizer/PathfinderVisualizer.jsx","PathfinderVisualizer/Initializers/GridReset.js","algorithms/dijkstra.js","algorithms/astar.js","PathfinderVisualizer/Visualizers/Visualize.js","algorithms/bfs_dfs.js","Components/Navbar.js","App.js","serviceWorker.js","index.js"],"names":["GridContext","createContext","state","action","type","grid","payload","start_vertex_row","start_vertex_col","finish_vertex_row","finish_vertex_col","mouseIsPressed","isDragging","original_row","original_col","translate_row","translate_col","last_translate_row","last_translate_col","distanceMethod","allowDiagonal","algorithm","ROWS","COLUMNS","Math","floor","window","innerWidth","GridState","props","initialState","useReducer","gridReducer","dispatch","Provider","value","setGrid","setStart","position","row","col","setFinish","setMouseIsPressed","pressed","setIsDragging","started_dragging","setOriginal","setTranslate","setLastTranslate","setDistanceMethod","method","setAllowDiagonal","diagonal","setAlgorithm","children","Vertex","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","isVisited","isPath","onDragStart","onDragOver","onDrop","extraClassName","start_overlay","id","xmlns","xmlnsXlink","width","height","viewBox","style","transform","fillRule","fill","d","finish_overlay","className","draggable","DistancePicker","getDistanceMethod","chooseDiagonal","getWhichAlgorithm","gridContext","React","useContext","handleDistanceMethod","event","target","handleAlgorithmMethod","FormGroup","textAlign","display","FormControlLabel","control","Radio","checked","onChange","name","label","disabled","Checkbox","createInitialGrid","start_finish","thisRow","push","createVertex","distance","Infinity","distanceToThis","heuristic","previousVertex","createGridWithWalls","wallGrid","vertex","newVertex","updateGrid","PathfinderVisualizer","useEffect","handleDrag","clearTheVisualOfVertex","thisVertex","document","getElementById","map","row_index","key","vertex_index","handleMouseDown","handleMouseEnter","e","vertexData","JSON","stringify","dataTransfer","setData","handleDragStart","preventDefault","stopPropagation","handleDragOver","new_position","parse","getData","dragged_from_position","empty_vertex","swapVertices","clearData","handleDrop","onDrag","resetGrid","dijkstra","start","finish","visitedInOrder","unvisitedVertices","getAllVertices","length","getTheClosestVerticesFirst","closestVertex","shift","console","log","updateUnvisitedNeighbors","vertices","sort","vertexA","vertexB","getUnvisitedNeighbors","hVDistance","dDistance","t","backtrackRoute","backtrackedVertices","currentVertex","unshift","astar","tempF","distanceFromStartToThis","calculateHeuristic","from","to","EuclideanDistance","Point","Goal","sqrt","pow","animateAlgorithm","starting_point","i","setTimeout","start_row","start_col","arrow","animateShortestPath","bfs_dfs","structure","neighbors","pop","getNeighbors","forEach","neighbor","Navbar","visualizeAlgorithm","startVertex","finishVertex","onClick","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.bf0dc186.chunk.js","sourcesContent":["import { createContext } from \"react\";\n\nconst GridContext = createContext();\n\nexport default GridContext;\n","/**\n *\n * Deleted all the get actions, because triggering the data\n * does not happen in the reducer. Only setting the state values happen\n * in reducer.\n * State values can be retrieved inside the functional component itself.\n *\n */\n\nimport {\n  SET_GRID,\n  SET_STARTING_ROW,\n  SET_STARTING_COL,\n  SET_FINISH_ROW,\n  SET_FINISH_COL,\n  SET_MOUSE_IS_PRESSED,\n  IS_DRAGGING,\n  SET_ORIGINAL_ROW,\n  SET_ORIGINAL_COL,\n  SET_TRANSLATE_ROW,\n  SET_TRANSLATE_COL,\n  SET_LAST_TRANSLATE_ROW,\n  SET_LAST_TRANSLATE_COL,\n  SET_DISTANCE_METHOD,\n  SET_ALLOW_DIAGONAL,\n  SET_ALGORITHM\n} from \"../types.js\";\n\nexport default (state, action) => {\n  switch (action.type) {\n    case SET_GRID:\n      return { ...state, grid: action.payload };\n\n    case SET_STARTING_ROW:\n      return { ...state, start_vertex_row: action.payload };\n\n    case SET_STARTING_COL:\n      return { ...state, start_vertex_col: action.payload };\n\n    case SET_FINISH_ROW:\n      return { ...state, finish_vertex_row: action.payload };\n\n    case SET_FINISH_COL:\n      return { ...state, finish_vertex_col: action.payload };\n\n    case SET_MOUSE_IS_PRESSED:\n      return { ...state, mouseIsPressed: action.payload };\n    // related to dragging :\n    case IS_DRAGGING:\n      return { ...state, isDragging: action.payload };\n\n    case SET_ORIGINAL_ROW:\n      return { ...state, original_row: action.payload };\n\n    case SET_ORIGINAL_COL:\n      return { ...state, original_col: action.payload };\n\n    case SET_TRANSLATE_ROW:\n      return { ...state, translate_row: action.payload };\n\n    case SET_TRANSLATE_COL:\n      return { ...state, translate_col: action.payload };\n\n    case SET_LAST_TRANSLATE_ROW:\n      return { ...state, last_translate_row: action.payload };\n\n    case SET_LAST_TRANSLATE_COL:\n      return { ...state, last_translate_col: action.payload };\n\n    case SET_DISTANCE_METHOD:\n      return {\n        ...state,\n        distanceMethod: action.payload\n      };\n\n    case SET_ALLOW_DIAGONAL:\n      return {\n        ...state,\n        allowDiagonal: action.payload\n      };\n\n    case SET_ALGORITHM:\n      return {\n        ...state,\n        algorithm: action.payload\n      };\n\n    default:\n      return state;\n  }\n};\n","export const SET_GRID = \"SET_GRID\";\nexport const SET_STARTING_ROW = \"SET_STARTING_ROW\";\nexport const SET_STARTING_COL = \"SET_STARTING_COL\";\nexport const SET_FINISH_ROW = \"SET_FINISH_ROW\";\nexport const SET_FINISH_COL = \"SET_FINISH_COL\";\n\nexport const SET_MOUSE_IS_PRESSED = \"SET_MOUSE_IS_PRESSED\";\n\nexport const IS_DRAGGING = \"IS_DRAGGING\";\n\nexport const SET_ORIGINAL_ROW = \"SET_ORIGINAL_ROW\";\nexport const SET_ORIGINAL_COL = \"SET_ORIGINAL_COL\";\n\nexport const SET_TRANSLATE_ROW = \"SET_TRANSLATE_ROW\";\nexport const SET_TRANSLATE_COL = \"SET_TRANSLATE_COL\";\n\nexport const SET_LAST_TRANSLATE_ROW = \"SET_LAST_TRANSLATE_ROW\";\nexport const SET_LAST_TRANSLATE_COL = \"SET_LAST_TRANSLATE_COL\";\nexport const SET_DISTANCE_METHOD = \"SET_DISTANCE_METHOD\";\nexport const SET_ALLOW_DIAGONAL = \"SET_ALLOW_DIAGONAL\";\n\nexport const SET_ALGORITHM = \"SET_ALGORITHM\";\n","export const ROWS = 25;\nexport const COLUMNS = Math.floor(window.innerWidth / 35);\nexport const FAST = 10;\nexport const MEDIUM = 40;\nexport const SLOW = 80;\nexport const speed = SLOW;\n\nexport const START_VERTEX_ROW_ = 3;\nexport const START_VERTEX_COL_ = 3;\nexport const FINISH_VERTEX_ROW_ = 3;\nexport const FINISH_VERTEX_COL_ = 7;\n","import React, { useReducer } from \"react\";\nimport gridContext from \"./gridContext\";\nimport gridReducer from \"./gridReducer\";\n\nimport {\n  START_VERTEX_ROW_,\n  START_VERTEX_COL_,\n  FINISH_VERTEX_ROW_,\n  FINISH_VERTEX_COL_\n} from \"../../parameters\";\n\nimport {\n  SET_GRID,\n  SET_STARTING_ROW,\n  SET_STARTING_COL,\n  SET_FINISH_ROW,\n  SET_FINISH_COL,\n  SET_MOUSE_IS_PRESSED,\n  IS_DRAGGING,\n  SET_ORIGINAL_ROW,\n  SET_ORIGINAL_COL,\n  SET_TRANSLATE_ROW,\n  SET_TRANSLATE_COL,\n  SET_LAST_TRANSLATE_ROW,\n  SET_LAST_TRANSLATE_COL,\n  SET_DISTANCE_METHOD,\n  SET_ALLOW_DIAGONAL,\n  SET_ALGORITHM\n} from \"../types.js\";\n\nconst GridState = props => {\n  const initialState = {\n    grid: [],\n\n    mouseIsPressed: false,\n\n    start_vertex_row: START_VERTEX_ROW_,\n    start_vertex_col: START_VERTEX_COL_,\n    finish_vertex_row: FINISH_VERTEX_ROW_,\n    finish_vertex_col: FINISH_VERTEX_COL_,\n\n    isDragging: false,\n\n    original_row: 0,\n    original_col: 0,\n\n    translate_row: 0,\n    translate_col: 0,\n\n    last_translate_row: 0,\n    last_translate_col: 0,\n\n    distanceMethod: \"manhattan\",\n\n    allowDiagonal: false,\n\n    algorithm: \"dijkstra\"\n  };\n\n  const [state, dispatch] = useReducer(gridReducer, initialState);\n\n  const setGrid = grid => {\n    dispatch({ type: SET_GRID, payload: grid });\n  };\n\n  const setStart = position => {\n    dispatch({ type: SET_STARTING_ROW, payload: position.row });\n    dispatch({ type: SET_STARTING_COL, payload: position.col });\n  };\n\n  const setFinish = position => {\n    dispatch({ type: SET_FINISH_ROW, payload: position.row });\n    dispatch({ type: SET_FINISH_COL, payload: position.col });\n  };\n\n  const setMouseIsPressed = pressed => {\n    dispatch({ type: SET_MOUSE_IS_PRESSED, payload: pressed });\n  };\n\n  //   for dragging actions\n  const setIsDragging = started_dragging => {\n    dispatch({ type: IS_DRAGGING, payload: started_dragging });\n  };\n\n  const setOriginal = position => {\n    dispatch({ type: SET_ORIGINAL_ROW, payload: position.row });\n    dispatch({ type: SET_ORIGINAL_COL, payload: position.col });\n  };\n\n  const setTranslate = position => {\n    dispatch({ type: SET_TRANSLATE_ROW, payload: position.row });\n    dispatch({ type: SET_TRANSLATE_COL, payload: position.col });\n  };\n\n  const setLastTranslate = position => {\n    dispatch({ type: SET_LAST_TRANSLATE_ROW, payload: position.row });\n    dispatch({ type: SET_LAST_TRANSLATE_COL, payload: position.col });\n  };\n\n  const setDistanceMethod = method => {\n    dispatch({ type: SET_DISTANCE_METHOD, payload: method });\n  };\n\n  const setAllowDiagonal = diagonal => {\n    dispatch({ type: SET_ALLOW_DIAGONAL, payload: diagonal });\n  };\n\n  const setAlgorithm = algorithm => {\n    dispatch({ type: SET_ALGORITHM, payload: algorithm });\n  };\n  return (\n    <gridContext.Provider\n      value={{\n        grid: state.grid,\n        setGrid,\n        setStart,\n        setFinish,\n        setMouseIsPressed,\n        setIsDragging,\n        setOriginal,\n        setTranslate,\n        setLastTranslate,\n        mouseIsPressed: state.mouseIsPressed,\n        start_vertex_row: state.start_vertex_row,\n        start_vertex_col: state.start_vertex_col,\n        finish_vertex_row: state.finish_vertex_row,\n        finish_vertex_col: state.finish_vertex_col,\n        isDragging: state.isDragging,\n        original_row: state.original_row,\n        original_col: state.original_col,\n        translate_row: state.translate_row,\n        translate_col: state.translate_col,\n        last_translate_row: state.last_translate_row,\n        last_translate_col: state.last_translate_col,\n        setDistanceMethod,\n        distanceMethod: state.distanceMethod,\n        allowDiagonal: state.allowDiagonal,\n        setAllowDiagonal,\n        setAlgorithm,\n        algorithm: state.algorithm\n      }}\n    >\n      {props.children}\n    </gridContext.Provider>\n  );\n};\n/**\n * ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n * this is where we return the state variables\n */\n\nexport default GridState;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport \"./Vertex.scss\";\nconst Vertex = props => {\n  const {\n    position,\n    isFinish,\n    isStart,\n    isWall,\n    onMouseDown,\n    onMouseEnter,\n    onMouseUp,\n    isVisited,\n    isPath,\n    onDragStart,\n    onDragOver,\n    onDrop\n  } = props;\n  const extraClassName = isFinish\n    ? \"vertex-finish\"\n    : isStart\n    ? \"vertex-start\"\n    : isWall\n    ? \"vertex-wall vertex-non-draggable\"\n    : isPath\n    ? \"vertex-shortest-path vertex-non-draggable\"\n    : isVisited\n    ? \"vertex-visited vertex-non-draggable\"\n    : \"vertex-non-draggable\";\n\n  const start_overlay = (\n    <svg\n      id=\"start-svg\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n      width=\"27px\"\n      height=\"27px\"\n      viewBox=\"0 0 54 54\"\n      style={{ transform: \"rotate(0deg)\" }}\n    >\n      <path\n        fillRule=\"evenodd\"\n        fill=\"#12375a\"\n        d=\"M24.996,49.999 C11.214,49.999 0.002,38.785 0.002,25.001 C0.002,11.216 11.214,0.001 24.996,0.001 C38.782,0.001 49.998,11.216 49.998,25.001 C49.998,38.785 38.782,49.999 24.996,49.999 ZM24.996,2.294 C12.479,2.294 2.296,12.480 2.296,25.001 C2.296,37.521 12.479,47.706 24.996,47.706 C37.517,47.706 47.704,37.521 47.704,25.001 C47.704,12.480 37.517,2.294 24.996,2.294 ZM14.887,41.362 L24.672,24.911 L14.887,8.971 L42.940,25.164 L14.887,41.362 Z\"\n      />\n    </svg>\n  );\n  const finish_overlay = (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n      width=\"27px\"\n      height=\"27px\"\n      viewBox=\"0 0 54 54\"\n    >\n      <path\n        fillRule=\"evenodd\"\n        fill=\"#12375a\"\n        d=\"M25.000,0.001 L33.239,15.714 L49.997,19.099 L38.332,32.195 L40.449,49.999 L25.000,42.379 L9.551,49.999 L11.668,32.195 L0.003,19.099 L16.761,15.714 L25.000,0.001 \"\n      />\n    </svg>\n  );\n  //   const start_circle = (\n  //     <svg\n  //       id=\"start-svg\"\n  //       xmlns=\"http://www.w3.org/2000/svg\"\n  //       xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n  //       width=\"27px\"\n  //       height=\"27px\"\n  //       viewBox=\"0 0 54 54\"\n  //       style={{ transform: \"rotate(0)\" }}\n  //     >\n  //       <path\n  //         fillRule=\"evenodd\"\n  //         fill=\"#12375a\"\n  //         d=\"M50.000,25.000 C50.000,38.807 38.807,50.000 25.000,50.000 C11.193,50.000 -0.000,38.807 -0.000,25.000 C-0.000,11.193 11.193,-0.000 25.000,-0.000 C38.807,-0.000 50.000,11.193 50.000,25.000 Z\"\n  //       />\n  //     </svg>\n  //   );\n  return (\n    <td\n      id={`vertex-${position.row}-${position.col}`}\n      className={`vertex ${extraClassName}`}\n      onMouseDown={() => onMouseDown(position)}\n      onMouseEnter={() => onMouseEnter(position)}\n      onMouseUp={() => onMouseUp(position)}\n      onDragStart={onDragStart}\n      onDragOver={onDragOver}\n      onDrop={onDrop}\n      draggable={(isStart || isFinish) && !isWall}\n    >\n      {isStart ? start_overlay : isFinish ? finish_overlay : \"\"}\n      {/* {(position.row, position.col)} */}\n    </td>\n  );\n};\n\nVertex.propTypes = {\n  position: PropTypes.object,\n  isFinish: PropTypes.bool,\n  isStart: PropTypes.bool,\n  isWall: PropTypes.bool,\n  onMouseDown: PropTypes.func,\n  onMouseUp: PropTypes.func,\n  onMouseEnter: PropTypes.func,\n  mouseIsPressed: PropTypes.bool\n};\n\nexport default Vertex;\n","import React from \"react\";\nimport Radio from \"@material-ui/core/Radio\";\nimport Checkbox from \"@material-ui/core/Checkbox\";\nimport FormControlLabel from \"@material-ui/core/FormControlLabel\";\nimport FormGroup from \"@material-ui/core/FormGroup\";\nimport \"./navbar.scss\";\nimport GridContext from \"../context/grid/gridContext\";\n\nconst DistancePicker = ({\n  getDistanceMethod,\n  chooseDiagonal,\n  getWhichAlgorithm\n}) => {\n  const gridContext = React.useContext(GridContext);\n  const {\n    allowDiagonal,\n    distanceMethod,\n    setAllowDiagonal,\n    setDistanceMethod,\n    setAlgorithm,\n    algorithm\n  } = gridContext;\n\n  const handleDistanceMethod = event => {\n    setDistanceMethod(event.target.value);\n    getDistanceMethod(event.target.value);\n  };\n\n  const handleDiagonal = event => {\n    setAllowDiagonal(event.target.checked);\n    chooseDiagonal(event.target.checked);\n  };\n\n  const handleAlgorithmMethod = event => {\n    setAlgorithm(event.target.value);\n    getWhichAlgorithm(event.target.value);\n  };\n\n  return (\n    <div className=\"algo-methods\">\n      <FormGroup row style={{ textAlign: \"center\", display: \"block\" }}>\n        <FormControlLabel\n          control={\n            <Radio\n              checked={algorithm === \"dijkstra\"}\n              onChange={handleAlgorithmMethod}\n              value=\"dijkstra\"\n              name=\"choose-distance-method\"\n              label=\"dijkstra\"\n            />\n          }\n          label=\"Dijkstra\"\n        />\n        <FormControlLabel\n          control={\n            <Radio\n              checked={algorithm === \"astar\"}\n              onChange={handleAlgorithmMethod}\n              value=\"astar\"\n              name=\"choose-distance-method\"\n              label=\"astar\"\n            />\n          }\n          label=\"A-star\"\n        />\n        <FormControlLabel\n          control={\n            <Radio\n              checked={algorithm === \"bfs\"}\n              onChange={handleAlgorithmMethod}\n              value=\"bfs\"\n              name=\"choose-distance-method\"\n              label=\"bfs\"\n            />\n          }\n          label=\"Breadth-First Search\"\n        />\n        <FormControlLabel\n          control={\n            <Radio\n              checked={algorithm === \"dfs\"}\n              onChange={handleAlgorithmMethod}\n              value=\"dfs\"\n              name=\"choose-distance-method\"\n              label=\"dfs\"\n            />\n          }\n          label=\"Depth-First Search\"\n        />\n      </FormGroup>\n\n      <FormGroup row style={{ textAlign: \"center\", display: \"block\" }}>\n        <FormControlLabel\n          control={\n            <Radio\n              checked={distanceMethod === \"manhattan\"}\n              onChange={handleDistanceMethod}\n              value=\"manhattan\"\n              name=\"choose-distance-method\"\n              label=\"m\"\n              disabled={algorithm === \"astar\" || !allowDiagonal}\n            />\n          }\n          label=\"manhattan\"\n        />\n        <FormControlLabel\n          control={\n            <Radio\n              checked={distanceMethod === \"chebyshev\"}\n              onChange={handleDistanceMethod}\n              value=\"chebyshev\"\n              name=\"choose-distance-method\"\n              label=\"c\"\n              disabled={algorithm === \"astar\" || !allowDiagonal}\n            />\n          }\n          label=\"chebyshev\"\n        />\n        <FormControlLabel\n          control={\n            <Radio\n              checked={distanceMethod === \"euclidean\"}\n              onChange={handleDistanceMethod}\n              value=\"euclidean\"\n              name=\"choose-distance-method\"\n              label=\"e\"\n              disabled={algorithm === \"astar\" || !allowDiagonal}\n            />\n          }\n          label=\"euclidean\"\n        />\n        <FormControlLabel\n          control={\n            <Checkbox\n              checked={allowDiagonal}\n              onChange={handleDiagonal}\n              disabled={algorithm === \"astar\"}\n            />\n          }\n          label=\"diagonal\"\n        />\n      </FormGroup>\n    </div>\n  );\n};\n\nexport default DistancePicker;\n","import { ROWS, COLUMNS } from \"../../parameters\";\n\nexport const createInitialGrid = start_finish => {\n  const grid = [];\n  for (let row = 0; row < ROWS; row++) {\n    const thisRow = [];\n    for (let col = 0; col < COLUMNS; col++) {\n      thisRow.push(createVertex({ row, col }, start_finish));\n    }\n    grid.push(thisRow);\n  }\n  // for testing\n  //   for (let row = 0; row < 20; row++) {\n  //     grid[row][14].isWall = true;\n  //   }\n  return grid;\n};\n\n// export const visualizeAlgorithm = () => {\n//   const gridContext = useContext(GridContext);\n\n//   const {\n//     grid,\n\n//     start_vertex_row,\n//     start_vertex_col,\n//     finish_vertex_row,\n//     finish_vertex_col,\n\n//     distanceMethod,\n//     allowDiagonal,\n\n//     algorithm\n//   } = gridContext;\n\n//   clearTheVisualOfVertex();\n//   document.getElementById(\"root\").style = \"pointer-events: none\";\n//   document.getElementById(\"btnStart\").disabled = true;\n//   document.getElementById(\"btnReset\").disabled = true;\n//   for (let row = 0; row < ROWS; row++) {\n//     for (let col = 0; col < COLUMNS; col++) {\n//       let thisVertex = grid[row][col];\n\n//       if (thisVertex.isStart)\n//         document.getElementById(`vertex-${row}-${col}`).className =\n//           \"vertex vertex-start\";\n//       else if (thisVertex.isFinish)\n//         document.getElementById(`vertex-${row}-${col}`).className =\n//           \"vertex vertex-finish\";\n//       else if (thisVertex.isWall)\n//         document.getElementById(`vertex-${row}-${col}`).className =\n//           \"vertex vertex-wall\";\n//       else if (thisVertex.isVisited)\n//         document.getElementById(`vertex-${row}-${col}`).className = \"vertex\";\n//     }\n//   }\n//   const startVertex = grid[start_vertex_row][start_vertex_col];\n//   const finishVertex = grid[finish_vertex_row][finish_vertex_col];\n//   let visitedInOrder;\n\n//   switch (algorithm) {\n//     case \"astar\":\n//       visitedInOrder = astar(grid, startVertex, finishVertex);\n//       break;\n//     case \"dijkstra\":\n//       visitedInOrder = dijkstra(\n//         grid,\n//         startVertex,\n//         finishVertex,\n//         distanceMethod,\n//         allowDiagonal\n//       );\n//       break;\n//     case \"dfs\":\n//       visitedInOrder = bfs_dfs(grid, startVertex, finishVertex, \"dfs\");\n//       break;\n//     case \"bfs\":\n//       visitedInOrder = bfs_dfs(grid, startVertex, finishVertex, \"bfs\");\n//       break;\n//     default:\n//       visitedInOrder = dijkstra(\n//         grid,\n//         startVertex,\n//         finishVertex,\n//         distanceMethod,\n//         allowDiagonal\n//       );\n//   }\n//   // console.log(grid);\n//   // console.log(visitedInOrder);\n//   const backtrackedVertices = backtrackRoute(finishVertex, startVertex);\n//   animateAlgorithm(visitedInOrder, backtrackedVertices);\n// };\n\nconst createVertex = (position, start_finish) => {\n  const {\n    start_vertex_row,\n    start_vertex_col,\n    finish_vertex_row,\n    finish_vertex_col\n  } = start_finish;\n  return {\n    position,\n    isStart:\n      position.row === start_vertex_row && position.col === start_vertex_col,\n    isFinish:\n      position.row === finish_vertex_row && position.col === finish_vertex_col,\n    distance: Infinity,\n    distanceToThis: 0,\n    heuristic: 0,\n    isVisited: false,\n    isWall: false,\n    isPath: false,\n    previousVertex: null,\n    draggable:\n      (position.row === start_vertex_row &&\n        position.col === start_vertex_col) ||\n      (position.row === finish_vertex_row && position.col === finish_vertex_col)\n  };\n};\n\nexport const createGridWithWalls = (grid, position) => {\n  const wallGrid = [...grid];\n  const vertex = wallGrid[position.row][position.col];\n  const newVertex = {\n    ...vertex,\n    isWall: !vertex.isWall, //changed here\n    isPath: false,\n    isVisited: false,\n    distance: Infinity,\n    distanceToThis: Infinity,\n    heuristic: Infinity,\n    draggable: false,\n    previousVertex: null\n  };\n  wallGrid[position.row][position.col] = newVertex;\n  return wallGrid;\n};\n\nexport const createGridWithWallsOnRowOrColumn = (\n  grid,\n  orientation,\n  start,\n  end,\n  division_point,\n  skip_this_cell\n) => {\n  console.log(\n    `Orientation is: ${orientation} Division point is ${division_point}, skipping the cell ${skip_this_cell}, `\n  );\n  const wallgrid = [...grid];\n  if (orientation === \"vertical\") {\n    for (let row = start; row < end; row++) {\n      if (\n        grid[row][division_point].isStart ||\n        grid[row][division_point].isFinish\n      )\n        continue;\n      if (row !== skip_this_cell) {\n        let vertex = wallgrid[row][division_point];\n        let newVertex = {\n          ...vertex,\n          isWall: !vertex.isWall, //changed here\n          isPath: false,\n          isVisited: false,\n          distance: Infinity,\n          distanceToThis: Infinity,\n          heuristic: Infinity,\n          draggable: false,\n          previousVertex: null\n        };\n        wallgrid[row][division_point] = newVertex;\n      }\n    }\n  } else {\n    for (let col = start; col < end; col++) {\n      if (\n        grid[division_point][col].isStart ||\n        grid[division_point][col].isFinish\n      )\n        continue;\n      if (col !== skip_this_cell) {\n        let vertex = wallgrid[division_point][col];\n        let newVertex = {\n          ...vertex,\n          isWall: !vertex.isWall, //changed here\n          isPath: false,\n          isVisited: false,\n          distance: Infinity,\n          distanceToThis: Infinity,\n          heuristic: Infinity,\n          draggable: false,\n          previousVertex: null\n        };\n        wallgrid[division_point][col] = newVertex;\n      }\n    }\n  }\n  return wallgrid;\n};\n\n//create a function for swapping a drid vertices\nexport const swapVertices = (grid, vertex, new_position) => {\n  const dragged_from_position = vertex.position;\n  // dropped at position\n  vertex.position = new_position;\n  grid[new_position.row][new_position.col] = vertex;\n  const empty_vertex = {\n    position: dragged_from_position,\n    isStart: false,\n    isFinish: false,\n    distance: Infinity,\n    distanceToThis: 0,\n    heuristic: 0,\n    isVisited: false,\n    isWall: false,\n    isPath: false,\n    previousVertex: null,\n    draggable: !vertex.draggable\n  };\n  grid[dragged_from_position.row][dragged_from_position.col] = empty_vertex;\n\n  vertex.distance = Infinity;\n  return grid;\n};\n\nexport const updateGrid = grid => {\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col < COLUMNS; col++) {\n      //check the vertex\n      grid[row][col].distance = Infinity;\n      grid[row][col].distanceToThis = 0;\n      grid[row][col].heuristic = 0;\n      grid[row][col].isPath = false;\n      grid[row][col].isVisited = false;\n      grid[row][col].previousVertex = null;\n    }\n  }\n  return grid;\n};\n","import React, { useEffect, useContext } from \"react\";\nimport GridContext from \"../context/grid/gridContext\";\nimport \"./PathfinderVisualizer.css\";\nimport Vertex from \"./Vertex/Vertex\";\nimport DistancePicker from \"../Components/Methods\";\n\nimport {\n  createInitialGrid,\n  createGridWithWalls,\n  swapVertices,\n  updateGrid\n} from \"./Initializers/GridInitializers\";\n\nimport { ROWS, COLUMNS } from \"../parameters\";\n\nconst PathfinderVisualizer = () => {\n  const gridContext = useContext(GridContext);\n\n  const {\n    grid,\n    setGrid,\n    setMouseIsPressed,\n    start_vertex_row,\n    start_vertex_col,\n    finish_vertex_row,\n    finish_vertex_col,\n    mouseIsPressed,\n    setStart,\n    setFinish,\n    setDistanceMethod,\n    setAllowDiagonal,\n    setAlgorithm\n  } = gridContext;\n\n  const start_finish = {\n    start_vertex_row,\n    start_vertex_col,\n    finish_vertex_row,\n    finish_vertex_col\n  };\n\n  useEffect(() => {\n    // eslint-disable-next-line\n    setGrid(createInitialGrid(start_finish));\n  }, []);\n\n  const handleDragStart = (event, position, vertex) => {\n    const { row, col } = position;\n\n    if (\n      !(row === start_vertex_row && col === start_vertex_col) &&\n      !(row === finish_vertex_row && col === finish_vertex_col)\n    ) {\n      return;\n    } else {\n      const vertexData = JSON.stringify(vertex);\n      event.dataTransfer.setData(\"vertex_data\", vertexData);\n    }\n\n    return;\n  };\n  const handleDragOver = (event, position) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const handleDrop = (event, new_position) => {\n    const vertex = JSON.parse(event.dataTransfer.getData(\"vertex_data\"));\n    if (vertex.isStart || vertex.isFinish) {\n      if (\n        (new_position.row === finish_vertex_row &&\n          new_position.col === finish_vertex_col) ||\n        (new_position.row === start_vertex_row &&\n          new_position.col === start_vertex_col)\n      )\n        return;\n    }\n    // reassign the start or finish vertex depending on the vertex.isFinish \\\\ vertex.isStart\n    if (vertex.isStart) {\n      setStart(new_position);\n    } else {\n      setFinish(new_position);\n    }\n    setGrid(swapVertices(grid, vertex, new_position));\n    setGrid(updateGrid(grid));\n    event.dataTransfer.clearData();\n  };\n\n  const handleDrag = position => {\n    return;\n  };\n\n  const clearTheVisualOfVertex = () => {\n    for (let row = 0; row < ROWS; row++) {\n      for (let col = 0; col < COLUMNS; col++) {\n        let thisVertex = grid[row][col];\n        if (thisVertex.isStart)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-start\";\n        else if (thisVertex.isFinish)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-finish\";\n        else if (thisVertex.isWall)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-wall vertex-non-draggable\";\n        else {\n          document.getElementById(`vertex-${row}-${col}`).className = \"vertex \";\n        }\n      }\n    }\n  };\n\n  const handleMouseDown = position => {\n    const { row, col } = position;\n\n    if (!grid[row][col].isStart && !grid[row][col].isFinish) {\n      const wallGrid = createGridWithWalls(grid, position);\n      setGrid(wallGrid);\n      updateGrid(wallGrid);\n      setMouseIsPressed(true);\n    }\n  };\n\n  const handleMouseEnter = position => {\n    const { row, col } = position;\n    if (!mouseIsPressed) return;\n    if (!grid[row][col].isStart && !grid[row][col].isFinish) {\n      const wallGrid = createGridWithWalls(grid, position);\n      setGrid(wallGrid);\n      updateGrid(wallGrid);\n    }\n  };\n  const handleMouseUp = position => {\n    setMouseIsPressed(false);\n  };\n\n  const chooseDiagonalMethod = event => {\n    setAllowDiagonal(event);\n    setGrid(updateGrid(grid));\n    clearTheVisualOfVertex();\n  };\n\n  const chooseDistanceMethod = event => {\n    setGrid(updateGrid(grid));\n    clearTheVisualOfVertex();\n    setDistanceMethod(event);\n  };\n  const chooseAlgorithm = event => {\n    setGrid(updateGrid(grid));\n    clearTheVisualOfVertex();\n    setAlgorithm(event);\n  };\n\n  //   const createMaze = () => {\n  //     setGrid(mazeGenerator(grid));\n  //     updateGrid(grid);\n  //   };\n  return (\n    <div>\n      <DistancePicker\n        getWhichAlgorithm={chooseAlgorithm}\n        getDistanceMethod={chooseDistanceMethod}\n        chooseDiagonal={chooseDiagonalMethod}\n      />\n      <table className=\"grid\" draggable=\"false\">\n        <tbody className=\"grid\" draggable=\"false\">\n          {grid.map((row, row_index) => {\n            return (\n              <tr className=\"row\" key={row_index}>\n                {row.map((vertex, vertex_index) => {\n                  const {\n                    position,\n                    isFinish,\n                    isStart,\n                    isWall,\n                    isVisited,\n                    isPath,\n                    distance\n                  } = vertex;\n                  return (\n                    <Vertex\n                      key={vertex_index}\n                      position={position}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      onMouseDown={position => handleMouseDown(position)}\n                      onMouseEnter={position => handleMouseEnter(position)}\n                      onMouseUp={position => handleMouseUp(position)}\n                      onDragStart={e => handleDragStart(e, position, vertex)}\n                      onDragOver={event => handleDragOver(event, position)}\n                      onDrop={event => handleDrop(event, position)}\n                      onDrag={handleDrag}\n                      mouseIsPressed={mouseIsPressed}\n                      isWall={isWall}\n                      distance={distance}\n                      isVisited={isVisited}\n                      isPath={isPath}\n                      draggable={(isStart || isFinish) && !isWall}\n                    ></Vertex>\n                  );\n                })}\n              </tr>\n            );\n          })}\n        </tbody>\n      </table>\n    </div>\n  );\n};\n\nexport default PathfinderVisualizer;\n","import { createInitialGrid } from \"../Initializers/GridInitializers\";\nimport { ROWS, COLUMNS } from \"../../parameters\";\n\nexport const resetGrid = (grid, setGrid, start_finish) => {\n  const resetGrid = createInitialGrid(start_finish);\n  setGrid(resetGrid);\n  for (let row = 0; row < ROWS; row++) {\n    for (let col = 0; col < COLUMNS; col++) {\n      let thisVertex = grid[row][col];\n      if (thisVertex.isStart)\n        document.getElementById(`vertex-${row}-${col}`).className =\n          \"vertex vertex-start\";\n      else if (thisVertex.isFinish)\n        document.getElementById(`vertex-${row}-${col}`).className =\n          \"vertex vertex-finish\";\n      else {\n        document.getElementById(`vertex-${row}-${col}`).className = \"vertex \";\n      }\n    }\n  }\n};\n","/**\n *\n * This performs the Dijkstra algorithm returning all vertices that were\n * visited. Change the previousVertex value of the vertex to\n * backtrack from the finish vertex to the start vertex\n *\n */\nexport const dijkstra = (\n  grid,\n  start,\n  finish,\n  distanceMethod,\n  allowDiagonal\n) => {\n  const visitedInOrder = [];\n  // assign start vertex distance 0\n  // by default the vertices are infinite distance away from the start\n  start.distance = 0;\n  // get all vertices\n  const unvisitedVertices = getAllVertices(grid);\n  while (unvisitedVertices.length !== 0) {\n    getTheClosestVerticesFirst(unvisitedVertices);\n    const closestVertex = unvisitedVertices.shift();\n    console.log(\"distance of closest vertex is: \", closestVertex.distance);\n    if (closestVertex.isWall) continue;\n    if (closestVertex.distance === Infinity) return visitedInOrder;\n    updateUnvisitedNeighbors(\n      closestVertex,\n      grid,\n      distanceMethod,\n      allowDiagonal\n    );\n    closestVertex.isVisited = true;\n    visitedInOrder.push(closestVertex);\n    // before was like this :\n    // updateUnvisitedNeighbors(closestVertex, grid);\n    if (closestVertex === finish) return visitedInOrder;\n  }\n};\n\nconst getAllVertices = grid => {\n  const vertices = [];\n  for (const row of grid) for (const vertex of row) vertices.push(vertex);\n  return vertices;\n};\n\n// sort the vertices by ascending distance value\n// we can use PriorityQueue to improve on performance\nconst getTheClosestVerticesFirst = unvisitedVertices => {\n  unvisitedVertices.sort(\n    (vertexA, vertexB) => vertexA.distance - vertexB.distance\n  );\n};\n\nconst updateUnvisitedNeighbors = (\n  vertex,\n  grid,\n  distanceMethod,\n  allowDiagonal\n) => {\n  getUnvisitedNeighbors(vertex, grid, distanceMethod, allowDiagonal);\n};\n\nconst getUnvisitedNeighbors = (vertex, grid, distanceMethod, allowDiagonal) => {\n  const { row, col } = vertex.position;\n\n  if (allowDiagonal) {\n    let hVDistance, dDistance;\n    switch (distanceMethod) {\n      case \"manhattan\":\n        hVDistance = 1;\n        dDistance = 2;\n        break;\n      case \"euclidean\":\n        hVDistance = 1;\n        dDistance = 1.4;\n        break;\n      case \"chebyshev\":\n        hVDistance = 1;\n        dDistance = 1;\n        break;\n      default:\n        hVDistance = 1;\n        dDistance = 2;\n    }\n    // Top\n    let t;\n    if (row - 1 >= 0) {\n      // Top Left\n      if (col - 1 > 0) {\n        t = grid[row - 1][col - 1];\n        if (\n          !t.isVisited &&\n          !t.isWall &&\n          t.distance > vertex.distance + dDistance\n        ) {\n          t.distance = vertex.distance + dDistance;\n          t.previousVertex = vertex;\n        }\n      }\n      // Top Top\n      t = grid[row - 1][col];\n      if (\n        !t.isVisited &&\n        !t.isWall &&\n        t.distance > vertex.distance + hVDistance\n      ) {\n        t.distance = vertex.distance + hVDistance;\n        t.previousVertex = vertex;\n      }\n\n      // Top Right\n      if (col + 1 < grid[0].length) {\n        t = grid[row - 1][col + 1];\n        if (\n          !t.isVisited &&\n          !t.isWall &&\n          t.distance > vertex.distance + dDistance\n        ) {\n          t.distance = vertex.distance + dDistance;\n          t.previousVertex = vertex;\n        }\n      }\n    }\n\n    // Right\n    if (col + 1 < grid[0].length) {\n      t = grid[row][col + 1];\n      if (\n        !t.isVisited &&\n        !t.isWall &&\n        t.distance > vertex.distance + hVDistance\n      ) {\n        t.distance = vertex.distance + hVDistance;\n        t.previousVertex = vertex;\n      }\n    }\n\n    // Down\n    if (row + 1 < grid.length) {\n      // Down Right\n      if (col + 1 < grid[0].length) {\n        t = grid[row + 1][col + 1];\n        if (\n          !t.isVisited &&\n          !t.isWall &&\n          t.distance > vertex.distance + dDistance\n        ) {\n          t.distance = vertex.distance + dDistance;\n          t.previousVertex = vertex;\n        }\n      }\n      // Down Down\n      t = grid[row + 1][col];\n      if (\n        !t.isVisited &&\n        !t.isWall &&\n        t.distance > vertex.distance + hVDistance\n      ) {\n        t.distance = vertex.distance + hVDistance;\n        t.previousVertex = vertex;\n      }\n\n      // Down Left\n      if (col - 1 >= 0) {\n        t = grid[row + 1][col - 1];\n        if (\n          !t.isVisited &&\n          !t.isWall &&\n          t.distance > vertex.distance + dDistance\n        ) {\n          t.distance = vertex.distance + dDistance;\n          t.previousVertex = vertex;\n        }\n      }\n    }\n    // Left\n    if (col - 1 > 0) {\n      t = grid[row][col - 1];\n      if (\n        !t.isVisited &&\n        !t.isWall &&\n        t.distance > vertex.distance + hVDistance\n      ) {\n        t.distance = vertex.distance + hVDistance;\n        t.previousVertex = vertex;\n      }\n    }\n  } else {\n    //  non diagonal movements only\n    if (\n      row > 0 &&\n      !grid[row - 1][col].isVisited &&\n      !grid[row - 1][col].isWall\n    ) {\n      grid[row - 1][col].distance = vertex.distance + 1;\n      grid[row - 1][col].previousVertex = vertex;\n    }\n    if (\n      col < grid[0].length - 1 &&\n      !grid[row][col + 1].isVisited &&\n      !grid[row][col + 1].isWall\n    ) {\n      grid[row][col + 1].distance = vertex.distance + 1;\n      grid[row][col + 1].previousVertex = vertex;\n    }\n    if (\n      row < grid.length - 1 &&\n      !grid[row + 1][col].isVisited &&\n      !grid[row + 1][col].isWall\n    ) {\n      grid[row + 1][col].distance = vertex.distance + 1;\n      grid[row + 1][col].previousVertex = vertex;\n    }\n    if (\n      col > 0 &&\n      !grid[row][col - 1].isVisited &&\n      !grid[row][col - 1].isWall\n    ) {\n      grid[row][col - 1].distance = vertex.distance + 1;\n      grid[row][col - 1].previousVertex = vertex;\n    }\n  }\n};\n\nexport const backtrackRoute = (finish, start) => {\n  const backtrackedVertices = [];\n  let currentVertex = finish;\n  currentVertex = currentVertex.previousVertex;\n  if (currentVertex === null) return backtrackedVertices;\n  while (currentVertex !== start) {\n    currentVertex.isPath = true;\n    backtrackedVertices.unshift(currentVertex);\n    currentVertex = currentVertex.previousVertex;\n  }\n  return backtrackedVertices;\n};\n","/**\n *\n * This performs the Dijkstra algorithm returning all vertices that were\n * visited. Change the previousVertex value of the vertex to\n * backtrack from the finish vertex to the start vertex\n *\n */\nexport const astar = (grid, start, finish) => {\n  console.log(\"starting astar\");\n  const visitedInOrder = [];\n  // assign start vertex distance 0\n  // by default the vertices are infinite distance away from the start\n  start.distance = 0;\n  // get all vertices\n  const unvisitedVertices = getAllVertices(grid);\n  while (unvisitedVertices.length !== 0) {\n    getTheClosestVerticesFirst(unvisitedVertices);\n    const closestVertex = unvisitedVertices.shift();\n\n    if (closestVertex.isWall) continue;\n    if (closestVertex.distance === Infinity) return visitedInOrder;\n    updateUnvisitedNeighbors(closestVertex, grid, start, finish);\n    closestVertex.isVisited = true;\n    visitedInOrder.push(closestVertex);\n    // before was like this :\n    // updateUnvisitedNeighbors(closestVertex, grid);\n    if (closestVertex === finish) return visitedInOrder;\n  }\n};\n\nconst getAllVertices = grid => {\n  const vertices = [];\n  for (const row of grid) for (const vertex of row) vertices.push(vertex);\n  return vertices;\n};\n\n// sort the vertices by ascending distance value\n// we can use PriorityQueue to improve on performance\nconst getTheClosestVerticesFirst = unvisitedVertices => {\n  unvisitedVertices.sort(\n    (vertexA, vertexB) => vertexA.distance - vertexB.distance\n  );\n};\n\nconst updateUnvisitedNeighbors = (vertex, grid, start, finish) => {\n  getUnvisitedNeighbors(vertex, grid, start, finish);\n};\n\nconst getUnvisitedNeighbors = (vertex, grid, start, finish) => {\n  const { row, col } = vertex.position;\n\n  // Top\n  let t;\n  if (row - 1 >= 0) {\n    // Top Left\n    if (col - 1 > 0) {\n      t = grid[row - 1][col - 1];\n      let tempF =\n        vertex.distanceToThis +\n        distanceFromStartToThis(vertex, t) +\n        calculateHeuristic(t, finish);\n      if (!t.isWall && !t.isVisited) {\n        if (t.distance === Infinity || t.distance < tempF) {\n          t.distanceToThis =\n            vertex.distanceToThis + distanceFromStartToThis(t, vertex);\n          t.heuristic = calculateHeuristic(t, finish);\n          t.distance = t.distanceToThis + t.heuristic;\n          t.previousVertex = vertex;\n        } else {\n          t.distance = tempF;\n        }\n      }\n    }\n    // Top Top\n    t = grid[row - 1][col];\n    let tempF =\n      vertex.distanceToThis +\n      distanceFromStartToThis(vertex, t) +\n      calculateHeuristic(t, finish);\n    if (!t.isWall && !t.isVisited) {\n      if (t.distance === Infinity || t.distance < tempF) {\n        t.distanceToThis =\n          vertex.distanceToThis + distanceFromStartToThis(t, vertex);\n        t.heuristic = calculateHeuristic(t, finish);\n        t.distance = t.distanceToThis + t.heuristic;\n        t.previousVertex = vertex;\n      } else {\n        t.distance = tempF;\n      }\n    }\n\n    // Top Right\n    if (col + 1 < grid[0].length) {\n      t = grid[row - 1][col + 1];\n      let tempF =\n        vertex.distanceToThis +\n        distanceFromStartToThis(vertex, t) +\n        calculateHeuristic(t, finish);\n      if (!t.isWall && !t.isVisited) {\n        if (t.distance === Infinity || t.distance < tempF) {\n          t.distanceToThis =\n            vertex.distanceToThis + distanceFromStartToThis(t, vertex);\n          t.heuristic = calculateHeuristic(t, finish);\n          t.distance = t.distanceToThis + t.heuristic;\n          t.previousVertex = vertex;\n        } else {\n          t.distance = tempF;\n        }\n      }\n    }\n  }\n\n  // Right\n  if (col + 1 < grid[0].length) {\n    t = grid[row][col + 1];\n    let tempF =\n      vertex.distanceToThis +\n      distanceFromStartToThis(vertex, t) +\n      calculateHeuristic(t, finish);\n    if (!t.isWall && !t.isVisited) {\n      if (t.distance === Infinity || t.distance < tempF) {\n        t.distanceToThis =\n          vertex.distanceToThis + distanceFromStartToThis(t, vertex);\n        t.heuristic = calculateHeuristic(t, finish);\n        t.distance = t.distanceToThis + t.heuristic;\n        t.previousVertex = vertex;\n      } else {\n        t.distance = tempF;\n      }\n    }\n  }\n\n  // Down\n  if (row + 1 < grid.length) {\n    // Down Right\n    if (col + 1 < grid[0].length) {\n      t = grid[row + 1][col + 1];\n      let tempF =\n        vertex.distanceToThis +\n        distanceFromStartToThis(vertex, t) +\n        calculateHeuristic(t, finish);\n      if (!t.isWall && !t.isVisited) {\n        if (t.distance === Infinity || t.distance < tempF) {\n          t.distanceToThis =\n            vertex.distanceToThis + distanceFromStartToThis(t, vertex);\n          t.heuristic = calculateHeuristic(t, finish);\n          t.distance = t.distanceToThis + t.heuristic;\n          t.previousVertex = vertex;\n        } else {\n          t.distance = tempF;\n        }\n      }\n    }\n    // Down Down\n    t = grid[row + 1][col];\n    let tempF =\n      vertex.distanceToThis +\n      distanceFromStartToThis(vertex, t) +\n      calculateHeuristic(t, finish);\n    if (!t.isWall && !t.isVisited) {\n      if (t.distance === Infinity || t.distance < tempF) {\n        t.distanceToThis =\n          vertex.distanceToThis + distanceFromStartToThis(t, vertex);\n        t.heuristic = calculateHeuristic(t, finish);\n        t.distance = t.distanceToThis + t.heuristic;\n        t.previousVertex = vertex;\n      } else {\n        t.distance = tempF;\n      }\n    }\n\n    // Down Left\n    if (col - 1 >= 0) {\n      t = grid[row + 1][col - 1];\n      let tempF =\n        vertex.distanceToThis +\n        distanceFromStartToThis(vertex, t) +\n        calculateHeuristic(t, finish);\n      if (!t.isWall && !t.isVisited) {\n        if (t.distance === Infinity || t.distance < tempF) {\n          t.distanceToThis =\n            vertex.distanceToThis + distanceFromStartToThis(t, vertex);\n          t.heuristic = calculateHeuristic(t, finish);\n          t.distance = t.distanceToThis + t.heuristic;\n          t.previousVertex = vertex;\n        } else {\n          t.distance = tempF;\n        }\n      }\n    }\n  }\n  // Left\n  if (col - 1 > 0) {\n    t = grid[row][col - 1];\n    let tempF =\n      vertex.distanceToThis +\n      distanceFromStartToThis(vertex, t) +\n      calculateHeuristic(t, finish);\n    if (!t.isWall && !t.isVisited) {\n      if (t.distance === Infinity || t.distance < tempF) {\n        t.distanceToThis =\n          vertex.distanceToThis + distanceFromStartToThis(t, vertex);\n        t.heuristic = calculateHeuristic(t, finish);\n        t.distance = t.distanceToThis + t.heuristic;\n        t.previousVertex = vertex;\n      } else {\n        t.distance = tempF;\n      }\n    }\n  }\n};\n\nexport const backtrackRoute = (finish, start) => {\n  const backtrackedVertices = [];\n  let currentVertex = finish;\n  //   currentVertex = currentVertex.previousVertex;\n  if (currentVertex === null) return backtrackedVertices;\n  while (currentVertex !== start) {\n    currentVertex.isPath = true;\n    backtrackedVertices.unshift(currentVertex);\n    currentVertex = currentVertex.previousVertex;\n  }\n  return backtrackedVertices;\n};\n\nconst calculateHeuristic = (from, to) =>\n  EuclideanDistance(from.position, to.position);\n\nconst distanceFromStartToThis = (from, to) => {\n  return EuclideanDistance(from.position, to.position);\n};\n\n// function ManhattanDistance(Point, Goal) {\n//   // linear movement - no diagonals - just cardinal directions (NSEW)\n//   return Math.abs(Point.row - Goal.row) + Math.abs(Point.col - Goal.col);\n// }\n\n// function DiagonalDistance(Point, Goal) {\n//   // diagonal movement - assumes diag dist is 1, same as cardinals\n//   return Math.max(\n//     Math.abs(Point.row - Goal.row),\n//     Math.abs(Point.col - Goal.col)\n//   );\n// }\n\nfunction EuclideanDistance(Point, Goal) {\n  return Math.sqrt(\n    Math.pow(Point.row - Goal.row, 2) + Math.pow(Point.col - Goal.col, 2)\n  );\n}\n\n/**\n *\n * Use onlu one Heuristic approach for solving the Astart algorithm\n * USE EUCLIDEAN DISTANCE HEURISTICS\n */\n","export const animateShortestPath = (starting_point, backtrackRoute) => {\n  const start_row = starting_point.start_vertex_row;\n  const start_col = starting_point.start_vertex_col;\n  for (let i = 0; i < backtrackRoute.length; i++) {\n    setTimeout(() => {\n      const vertex = backtrackRoute[i];\n      const row = vertex.position.row;\n      const col = vertex.position.col;\n      /* determine the direction at which the move will go. 1 of 8 directions */\n      /* right, down-right, down, down-left .... up, up-right */\n      const arrow = document.getElementById(\"start-svg\");\n      if (i === 0) {\n        console.log(\"inside if statement\");\n        console.log(vertex.position);\n        if (row === start_row && col === start_col + 1)\n          arrow.style.transform = \"rotate(0deg)\";\n        else if (row === start_row + 1 && col === start_col + 1)\n          arrow.style.transform = \"rotate(45deg)\";\n        else if (row === start_row + 1 && col === start_col)\n          arrow.style.transform = \"rotate(90deg)\";\n        else if (row === start_row + 1 && col === start_col - 1)\n          arrow.style.transform = \"rotate(135deg)\";\n        else if (row === start_row && col === start_col - 1)\n          arrow.style.transform = \"rotate(180deg)\";\n        else if (row === start_row - 1 && col === start_col - 1)\n          arrow.style.transform = \"rotate(-135deg)\";\n        else if (row === start_row - 1 && col === start_col)\n          arrow.style.transform = \"rotate(-90deg)\";\n        else if (row === start_row - 1 && col === start_col + 1)\n          arrow.style.transform = \"rotate(-45deg)\";\n      }\n      document.getElementById(\n        `vertex-${vertex.position.row}-${vertex.position.col}`\n      ).className = \"vertex vertex-shortest-path\";\n    }, 40 * i);\n  }\n  document.getElementById(\"btnStart\").disabled = false;\n  document.getElementById(\"btnReset\").disabled = false;\n  document.getElementById(\"root\").style = \"pointer-events: initial\";\n};\n\nexport const animateAlgorithm = (\n  starting_point,\n  visitedInOrder,\n  backtrackedVertices\n) => {\n  for (let i = 0; i <= visitedInOrder.length; i++) {\n    if (i === visitedInOrder.length) {\n      setTimeout(() => {\n        animateShortestPath(starting_point, backtrackedVertices);\n      }, 40 * i);\n      return;\n    }\n    setTimeout(() => {\n      const row = visitedInOrder[i].position.row;\n      const col = visitedInOrder[i].position.col;\n      const isStart = visitedInOrder[i].isStart;\n      const isFinish = visitedInOrder[i].isFinish;\n\n      if (!(isStart || isFinish))\n        document.getElementById(`vertex-${row}-${col}`).className =\n          \"vertex vertex-visited\";\n    }, 40 * i);\n  }\n};\n","export const bfs_dfs = (grid, start, finish, algorithm) => {\n  if (!start || !finish || start === finish) return [];\n  let visitedInOrder = [];\n  let structure = [];\n  structure.push(start);\n  let currentVertex;\n  let neighbors = [];\n\n  //  dfs\n  if (algorithm === \"dfs\") {\n    while (structure.length) {\n      currentVertex = structure.pop();\n      currentVertex.isVisited = true;\n\n      if (currentVertex === finish) return visitedInOrder;\n      visitedInOrder.push(currentVertex);\n      neighbors = getNeighbors(grid, currentVertex);\n      neighbors.forEach(neighbor => {\n        if (!neighbor.isVisited) {\n          neighbor.previousVertex = currentVertex;\n          structure.push(neighbor);\n        }\n      });\n    }\n  } else {\n    while (structure.length) {\n      currentVertex = structure.shift();\n      //   if (!currentVertex.isVisited) {\n      currentVertex.isVisited = true;\n      if (currentVertex === finish) return visitedInOrder;\n      neighbors = getNeighbors(grid, currentVertex);\n      visitedInOrder.push(currentVertex);\n      neighbors.forEach(neighbor => {\n        if (neighbor.isVisited === false) {\n          neighbor.previousVertex = currentVertex;\n          console.log(\"pushed neighbor is\", neighbor);\n          structure.push(neighbor);\n          neighbor.isVisited = true;\n        } else {\n          console.log(\"neighbor is visited\");\n        }\n      });\n      //   }\n    }\n  }\n  return visitedInOrder;\n};\n\nconst getNeighbors = (grid, vertex) => {\n  const { row, col } = vertex.position;\n  const neighbors = [];\n  if (row > 0 && !grid[row - 1][col].isWall && !grid[row - 1][col].isVisited)\n    neighbors.push(grid[row - 1][col]);\n  if (\n    col < grid[0].length - 1 &&\n    !grid[row][col + 1].isWall &&\n    !grid[row][col + 1].isVisited\n  )\n    neighbors.push(grid[row][col + 1]);\n  if (\n    row < grid.length - 1 &&\n    !grid[row + 1][col].isWall &&\n    !grid[row + 1][col].isVisited\n  )\n    neighbors.push(grid[row + 1][col]);\n  if (col > 0 && !grid[row][col - 1].isWall && !grid[row][col - 1].isVisited)\n    neighbors.push(grid[row][col - 1]);\n\n  return neighbors;\n};\n","import React, { useContext } from \"react\";\nimport \"./navbar.scss\";\nimport { resetGrid } from \"../PathfinderVisualizer/Initializers/GridReset\";\nimport GridContext from \"../context/grid/gridContext\";\nimport { dijkstra, backtrackRoute } from \"../algorithms/dijkstra\";\nimport { astar } from \"../algorithms/astar\";\nimport { animateAlgorithm } from \"../PathfinderVisualizer/Visualizers/Visualize\";\nimport { bfs_dfs } from \"../algorithms/bfs_dfs\";\nimport { ROWS, COLUMNS } from \"../parameters\";\n\nfunction Navbar() {\n  const gridContext = useContext(GridContext);\n\n  const {\n    grid,\n    setGrid,\n\n    start_vertex_row,\n    start_vertex_col,\n    finish_vertex_row,\n    finish_vertex_col,\n\n    distanceMethod,\n    allowDiagonal,\n\n    algorithm\n  } = gridContext;\n\n  const start_finish = {\n    start_vertex_row,\n    start_vertex_col,\n    finish_vertex_row,\n    finish_vertex_col\n  };\n\n  const clearTheVisualOfVertex = () => {\n    for (let row = 0; row < ROWS; row++) {\n      for (let col = 0; col < COLUMNS; col++) {\n        let thisVertex = grid[row][col];\n        if (thisVertex.isStart)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-start\";\n        else if (thisVertex.isFinish)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-finish\";\n        else if (thisVertex.isWall)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-wall vertex-non-draggable\";\n        else {\n          document.getElementById(`vertex-${row}-${col}`).className = \"vertex \";\n        }\n      }\n    }\n  };\n\n  const visualizeAlgorithm = () => {\n    clearTheVisualOfVertex();\n    document.getElementById(\"root\").style = \"pointer-events: none\";\n    document.getElementById(\"btnStart\").disabled = true;\n    document.getElementById(\"btnReset\").disabled = true;\n    for (let row = 0; row < ROWS; row++) {\n      for (let col = 0; col < COLUMNS; col++) {\n        let thisVertex = grid[row][col];\n\n        if (thisVertex.isStart)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-start\";\n        else if (thisVertex.isFinish)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-finish\";\n        else if (thisVertex.isWall)\n          document.getElementById(`vertex-${row}-${col}`).className =\n            \"vertex vertex-wall\";\n        else if (thisVertex.isVisited)\n          document.getElementById(`vertex-${row}-${col}`).className = \"vertex\";\n      }\n    }\n    const startVertex = grid[start_vertex_row][start_vertex_col];\n    const finishVertex = grid[finish_vertex_row][finish_vertex_col];\n    let visitedInOrder;\n\n    switch (algorithm) {\n      case \"astar\":\n        visitedInOrder = astar(grid, startVertex, finishVertex);\n        break;\n      case \"dijkstra\":\n        visitedInOrder = dijkstra(\n          grid,\n          startVertex,\n          finishVertex,\n          distanceMethod,\n          allowDiagonal\n        );\n        break;\n      case \"dfs\":\n        visitedInOrder = bfs_dfs(grid, startVertex, finishVertex, \"dfs\");\n        break;\n      case \"bfs\":\n        visitedInOrder = bfs_dfs(grid, startVertex, finishVertex, \"bfs\");\n        break;\n      default:\n        visitedInOrder = dijkstra(\n          grid,\n          startVertex,\n          finishVertex,\n          distanceMethod,\n          allowDiagonal\n        );\n    }\n    // console.log(grid);\n    // console.log(visitedInOrder);\n    const backtrackedVertices = backtrackRoute(finishVertex, startVertex);\n    animateAlgorithm(\n      { start_vertex_row, start_vertex_col },\n      visitedInOrder,\n      backtrackedVertices\n    );\n  };\n\n  return (\n    <div className=\"container\">\n      <h2>Pathfinder Algorithms Visualization</h2>\n\n      <nav className=\"main-nav\">\n        {/* <div className=\"algorithms-methods\">\n          <h1>something</h1>\n        </div> */}\n        <div className=\"buttons\">\n          <button\n            id=\"btnStart\"\n            className=\"brk-btn\"\n            onClick={() => visualizeAlgorithm()}\n          >\n            Start\n          </button>\n          <button\n            id=\"btnReset\"\n            className=\"brk-btn\"\n            onClick={() => resetGrid(grid, setGrid, start_finish)}\n          >\n            Reset Grid\n          </button>\n        </div>\n      </nav>\n    </div>\n  );\n}\n\nexport default Navbar;\n","import React from \"react\";\nimport \"./App.css\";\nimport GridState from \"./context/grid/GridState\";\nimport PathfinderVisualizer from \"./PathfinderVisualizer/PathfinderVisualizer\";\nimport Navbar from \"./Components/Navbar\";\n\nfunction App() {\n  return (\n    <GridState>\n      <div className=\"App\" draggable=\"false\">\n        <Navbar />\n\n        <PathfinderVisualizer />\n      </div>\n    </GridState>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.scss\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}